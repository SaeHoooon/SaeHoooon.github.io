<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ì™„ë²½í•œ ì»¨ë‹</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; font-family: 'Malgun Gothic', sans-serif; background: #000;}
    #gameContainer { width: 100vw; height: 100vh; }

    /* ë¡œë”© í™”ë©´ */
    #loadingScreen{
      position:absolute; inset:0; background:#000;
      display:flex; align-items:center; justify-content:center;
      color:#fff; font-size:24px; z-index:2000;
    }
    #loadingScreen.hidden{ display:none; }
    .loading-content{ text-align:center; }
    .loading-bar{ width:200px; height:4px; background:rgba(255,255,255,0.3); border-radius:2px; overflow:hidden; margin-top:20px; }
    .loading-progress{ width:100%; height:100%; background:#4CAF50; animation:loading 1.5s ease-in-out infinite; }
    @keyframes loading{ 0%,100%{ transform:translateX(-100%);} 50%{ transform:translateX(100%);} }

    /* ëŒ€í™”ì°½ í™”ë©´ */
    #dialogueScreen {
      position: absolute; inset: 0;
      z-index: 1500;
      display: none; flex-direction: column; justify-content: flex-end; align-items: center;
      padding-bottom: 50px;
      transition: background 0.5s ease-in-out; 
    }

    /* ì¡°ì‘ë²• ì„¤ëª… í™”ë©´ */
    #instructionScreen {
      position: absolute; inset: 0;
      z-index: 1600;
      background: rgba(0, 0, 0, 0.85);
      display: none; flex-direction: column; align-items: center; justify-content: center;
      color: #fff;
    }
    .inst-box {
      background: #222; padding: 40px; border-radius: 15px; border: 2px solid #555;
      text-align: center; box-shadow: 0 0 30px rgba(0,0,0,0.8); 
      max-width: 800px; width: 90%;
    }
    .inst-box h2 { color: #ffeb3b; margin-bottom: 30px; font-size: 32px; }
    .inst-row {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 15px; font-size: 20px; border-bottom: 1px solid #444; padding-bottom: 10px;
    }
    .key {
      background: #eee; color: #000; padding: 5px 10px; border-radius: 5px; font-weight: bold; font-family: monospace;
    }
    .warning-text { color: #ff5252; font-weight: bold; margin-top: 20px; font-size: 18px; }
    .goal-text { color: #4CAF50; font-weight: bold; margin-top: 10px; font-size: 18px; margin-bottom: 20px; }
    .start-game-btn {
      margin-top: 10px; padding: 15px 40px; font-size: 24px;
      background: #4CAF50; color: #fff; border: none; border-radius: 50px;
      cursor: pointer; font-weight: bold; transition: transform 0.2s;
    }
    .start-game-btn:hover { transform: scale(1.05); background: #45a049; }

    /* ë°°ê²½ ìŠ¤íƒ€ì¼ */
    .bg-home { background: rgba(0,0,0,0.1); }
    .bg-spotlight {
      background: radial-gradient(circle at center, rgba(255,255,255,0.15) 0%, rgba(0,0,0,0.95) 40%, #000 70%);
      background-color: #000;
    }
    .bg-school { background: rgba(0,0,0,0.3); }

    .dialogue-box {
      width: 80%; max-width: 800px;
      background: rgba(0, 0, 0, 0.85);
      border: 2px solid #fff;
      border-radius: 10px;
      padding: 30px;
      color: #fff; font-size: 20px; line-height: 1.6;
      box-shadow: 0 0 20px rgba(0,0,0,0.8);
      position: relative;
      transition: opacity 0.5s;
    }
    .speaker-name { font-size: 24px; font-weight: bold; color: #ffeb3b; margin-bottom: 15px; }
    .dialogue-text { min-height: 60px; }
    .next-guide {
      position: absolute; bottom: 15px; right: 20px;
      font-size: 14px; color: #aaa; animation: blink 1s infinite;
    }
    @keyframes blink { 50% { opacity: 0; } }

    /* HUD & UI */
    #hud{
      position:absolute; top:20px; left:20px;
      color:#fff; font-size:18px;
      text-shadow:2px 2px 4px rgba(0,0,0,0.8);
      user-select:none; pointer-events: none; display:none;
    }
    #warningArea {
      position: absolute; top: 60px; left: 20px;
      display: flex; gap: 10px; pointer-events: none;
    }
    .yellow-card {
      width: 30px; height: 45px;
      background-color: #ffeb3b;
      border: 2px solid #fff; border-radius: 4px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
      animation: cardPop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    @keyframes cardPop { 0% { transform: scale(0) rotate(-180deg); opacity: 0; } 100% { transform: scale(1) rotate(0deg); opacity: 1; } }

    #damageOverlay {
      position: absolute; inset: 0;
      background: radial-gradient(circle, transparent 60%, rgba(255, 0, 0, 0.5));
      opacity: 0; transition: opacity 0.2s; pointer-events: none; z-index: 500;
    }

    /* ì‹œí—˜ ì‹œê°„ ì¢…ë£Œ ë©”ì‹œì§€ ìŠ¤íƒ€ì¼ */
    #timeUpMessage {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-size: 80px;
      color: #ffeb3b;
      font-weight: bold;
      text-shadow: 4px 4px 0px #f44336;
      display: none;
      z-index: 2500;
      white-space: nowrap;
      pointer-events: none;
    }

    #cheatSheet {
      position: absolute; top: 20px; right: 20px;
      width: 400px; padding: 20px;
      background: rgba(255, 255, 255, 0.95);
      color: #000; border-radius: 5px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3); display: none;
      font-size: 16px; line-height: 1.6; transform: rotate(-2deg); border: 1px solid #ccc;
      white-space: nowrap; 
    }
    #cheatSheet h3 { text-align: center; margin-bottom: 10px; border-bottom: 2px solid #333; padding-bottom: 5px;}

    #answerSheet {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 650px; height: 500px;
      background: #fff; border: 1px solid #ccc;
      box-shadow: 0 20px 50px rgba(0,0,0,0.5); padding: 30px; display: none; 
      flex-direction: column; border-radius: 2px; z-index: 1200;
    }
    #answerSheet h2 { text-align: center; margin-bottom: 10px; font-family: "Gungsuh", serif; }
    .answer-warning {
      text-align: center; color: #d32f2f; font-weight: bold; font-size: 15px; margin-bottom: 10px;
      background: #ffebee; padding: 5px; border-radius: 4px;
    }

    #answerInput {
      flex: 1; width: 100%; padding: 15px; font-size: 16px; line-height: 1.8;
      border: 2px solid #ddd; background: #fdfdfd; resize: none; font-family: 'Malgun Gothic', sans-serif; outline: none;
    }
    #answerInput:focus { border-color: #4CAF50; }
    .sheet-guide { margin-top: 10px; font-size: 14px; color: #666; text-align: right; }

    #statusMsg {
      position: absolute; bottom: 100px; left: 50%;
      transform: translateX(-50%);
      color: #fff; font-size: 20px; font-weight: bold;
      text-shadow: 1px 1px 2px #000;
      opacity: 0; transition: opacity 0.3s; z-index: 1000;
    }
    #statusMsg.warning { color: #ffeb3b; font-size: 24px; text-shadow: 0 0 10px #f44336; }

    #controls{
      position:absolute; bottom:20px; left:20px;
      color:#fff; font-size:17px;
      text-shadow:2px 2px 4px rgba(0,0,0,0.8);
      background:rgba(0,0,0,0.5);
      padding:15px; border-radius:5px;
      user-select:none; pointer-events: none; display:none;
      line-height: 1.6;
    }

    /* ì±„ì  í™”ë©´ */
    #gradingScreen {
      position: absolute; inset: 0;
      background: rgba(0,0,0,0.9);
      color: #fff;
      display: none; flex-direction: column; align-items: center; justify-content: center;
      z-index: 1400; padding: 40px;
    }
    .grading-title { font-size: 36px; margin-bottom: 20px; font-weight: bold; color: #ffeb3b; }
    
    .grading-score {
      font-size: 48px; font-weight: bold; margin-bottom: 30px;
      text-shadow: 0 0 20px rgba(255,255,255,0.3);
    }

    .grading-table {
      display: flex; gap: 40px; width: 100%; max-width: 1200px;
      background: #222; padding: 20px; border-radius: 10px;
    }
    .grading-col { flex: 1; display: flex; flex-direction: column; gap: 10px; }
    .col-header { font-size: 24px; border-bottom: 2px solid #555; padding-bottom: 10px; margin-bottom: 10px; text-align: center;}
    .grade-item {
      background: #333; padding: 10px; border-radius: 5px; font-size: 16px; min-height: 45px; display: flex; align-items: center;
      word-break: break-all;
    }
    .grade-item.correct { border-left: 5px solid #4CAF50; color: #a5d6a7; }
    .grade-item.wrong { border-left: 5px solid #f44336; color: #ef9a9a; }
    .grading-btn {
      margin-top: 30px; padding: 15px 40px; font-size: 20px;
      background: #fff; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;
    }
    .grading-btn:hover { background: #eee; }

    /* THE END í™”ë©´ */
    #theEndScreen {
      position: absolute; inset: 0;
      display: none; flex-direction: column; align-items: center; justify-content: center;
      color: #fff; z-index: 3000; opacity: 0; transition: opacity 2s;
    }
    .the-end-text { font-size: 60px; font-weight: bold; margin-bottom: 20px; text-shadow: 0 0 20px rgba(255,255,255,0.5); }
    .the-end-sub { font-size: 28px; color: #ccc; margin-bottom: 40px; font-weight: normal; text-align: center; }
    .restart-btn {
      padding: 15px 30px; font-size: 24px; border: none; border-radius: 50px; 
      cursor: pointer; background: #ffeb3b; color: #000; font-weight: bold;
      box-shadow: 0 0 20px rgba(255, 235, 59, 0.5);
      transition: transform 0.2s;
    }
    .restart-btn:hover { transform: scale(1.1); }
  </style>
</head>
<body>
  <div id="gameContainer"></div>
  <div id="damageOverlay"></div>

  <div id="loadingScreen">
    <div class="loading-content">
      <div>ê²Œì„ ë¦¬ì†ŒìŠ¤ ë¡œë”© ì¤‘...</div>
      <div class="loading-bar"><div class="loading-progress"></div></div>
    </div>
  </div>

  <div id="dialogueScreen">
    <div class="dialogue-box" id="dialogueBox">
      <div class="speaker-name" id="speakerName"></div>
      <div class="dialogue-text" id="dialogueText"></div>
      <div class="next-guide">Enter í‚¤ë¥¼ ëˆŒëŸ¬ ê³„ì† â–¶</div>
      <div style="font-size: 14px; color: #aaa; margin-top: 5px;">(WASD: ì´ë™, ë§ˆìš°ìŠ¤: ì‹œì„ )</div>
    </div>
  </div>

  <div id="instructionScreen">
    <div class="inst-box">
      <h2>ğŸ® ê²Œì„ ì¡°ì‘ë²•</h2>
      <div class="inst-row"><span class="key">Space</span> <span>(ëˆ„ë¥´ê³  ìˆê¸°) ê³ ê°œ ë“¤ì–´ ì»¨ë‹</span></div>
      <div class="inst-row"><span class="key">9</span> <span>ë‹µì•ˆ ì‘ì„± ì‹œì‘</span></div>
      <div class="inst-row"><span class="key">0</span> <span>ì‘ì„± ì¤‘ë‹¨</span></div> 
      <div class="inst-row"><span class="key">Mouse</span> <span>ì‹œì•¼ ì¡°ì ˆ</span></div>
      
      <div class="warning-text">âš ï¸ ì£¼ì˜: ê²½ê³  3íšŒ ëˆ„ì  ì‹œ ì¦‰ì‹œ ë¶€ì •í–‰ìœ„ ì²˜ë¦¬ (GAME OVER)</div>
      <div class="goal-text">ğŸ¯ ëª©í‘œ: ê°ë…ê´€ë‹˜ê»˜ ê±¸ë¦¬ì§€ ì•Šê³  ê³¼íƒ‘ì˜ ë‹µì•ˆì„ ì™„ë²½í•˜ê²Œ ì»¨ë‹í•˜ì„¸ìš”!</div>

      <button class="start-game-btn" onclick="closeInstructions()">ì‹œí—˜ ì‹œì‘!</button>
    </div>
  </div>

  <div id="timeUpMessage">ì‹œí—˜ ì‹œê°„ ì¢…ë£Œ!</div>

  <div id="gradingScreen">
    <div class="grading-title">ğŸ“ ë‹µì•ˆì§€ ì±„ì  ì¤‘...</div>
    <div id="gradingScoreDisplay" class="grading-score"></div>
    
    <div class="grading-table">
      <div class="grading-col">
        <div class="col-header" style="color:#4CAF50">ì •ë‹µ (ëª¨ë²” ë‹µì•ˆ)</div>
        <div id="correctList"></div>
      </div>
      <div class="grading-col">
        <div class="col-header" style="color:#ff9800">ë‚´ê°€ ì“´ ë‹µì•ˆ</div>
        <div id="myList"></div>
      </div>
    </div>
    <button class="grading-btn" onclick="finishGrading()">ê²°ê³¼ í™•ì¸</button>
  </div>

  <div id="hud">
    <div>â±ï¸ ë‚¨ì€ ì‹œê°„: <span id="timeLeft">80</span>ì´ˆ</div>
  </div>
  <div id="warningArea"></div>

  <div id="cheatSheet">
    <h3>[ì•ìë¦¬ ê³¼íƒ‘ ë‹µì•ˆì§€]</h3>
    <div id="cheatContent"></div>
  </div>

  <div id="answerSheet">
    <h2>ê¸°ë§ê³ ì‚¬ ë‹µì•ˆì§€</h2>
    <div class="answer-warning">â€» ì£¼ì˜: ë²ˆí˜¸ ìƒëµ, ë‹µë§Œ í•œ ì¤„ì— í•˜ë‚˜ì”©! (ëŒ€ì†Œë¬¸ì/ê¸°í˜¸ ì •í™•íˆ êµ¬ë¶„!)</div>
    <textarea id="answerInput" placeholder="[ì‘ì„± ì˜ˆì‹œ]&#13;&#10;orthographic projection&#13;&#10;MeshLambertMaterial"></textarea>
    <div class="sheet-guide">0ì„ ëˆŒëŸ¬ ì‘ì„± ì¤‘ì§€</div>
  </div>

  <div id="statusMsg"></div>

  <div id="controls">
    <div style="margin-bottom:5px;"><b>ğŸ® ì¡°ì‘ë²•</b></div>
    <div>- <b>ìŠ¤í˜ì´ìŠ¤ë°”</b> : ê³ ê°œë¥¼ ë“¤ì–´ ì»¨ë‹í•˜ê¸°</div>
    <div>- <b>9</b> : ë‹µì•ˆ ì‘ì„±</div>
    <div>- <b>0</b> : ì‘ì„± ì¤‘ë‹¨</div>
    <div style="margin-top:5px; font-size: 0.9em; color:#ddd;">(ë§ˆìš°ìŠ¤: ì‹œì•¼ ì¡°ì ˆ)</div>
  </div>

  <div id="theEndScreen">
    <div class="the-end-text">THE END ...</div>
    <div class="the-end-sub" id="theEndSub"></div>
    <button class="restart-btn" onclick="location.reload()">ğŸ”„ ì²˜ìŒìœ¼ë¡œ ëŒì•„ê°€ê¸°</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const INTRO_DIALOGUES = [
      { speaker: "ì—„ë§ˆ", text: "ë„ˆ ìš”ì¦˜ ê³µë¶€ì•ˆí•˜ê³  ë†€ëŸ¬ë‹¹ê¸´ë‹¤ë©°?", color: "#ff6b6b" },
      { speaker: "ë‚˜", text: "ì•„ë‹ˆì—ìš”! ì œê°€ ì–¼ë§ˆë‚˜ ê³µë¶€ë¥¼ ì—´ì‹¬íˆ í•˜ëŠ”ë°ìš” ....", color: "#4488ff" },
      { speaker: "ì—„ë§ˆ", text: "ë„ˆ ë‚´ì¼ ì‹œí—˜ ì•„ë‹ˆë‹ˆ? ì´ë²ˆì— ë§Œì  ëª» ë°›ì•„ì˜¤ë©´ ìš©ëˆ ëŠì„ ì¤„ ì•Œì•„ë¼!", color: "#ff6b6b" },
      { speaker: "ë‚˜", text: "( ... í°ì¼ë‚¬ë‹¤. ì‚¬ì‹¤ ê³µë¶€ë¥¼ í•˜ë‚˜ë„ ì•ˆ í–ˆëŠ”ë°. )", color: "#aaa" },
      { speaker: "ë‚˜", text: "ì•„ ë§ë‹¤! ë‚´ì¼ ê³¼íƒ‘ ë’¤ì— ì•‰ì•„ì•¼ì§€!!", color: "#4CAF50" },
      { speaker: "ë‚˜", text: "ì–´ë–»ê²Œë“  ê±” ë‹µì•ˆì„ ì»¨ë‹í•´ì„œ A+ë¥¼ ë°›ì•„ì•¼ í•´!", color: "#4CAF50" }
    ];

    const ENDING_SCENARIOS = {
      caught: [
        { speaker: "ì—„ë§ˆ", text: "ë„ˆ... ì„ ìƒë‹˜ê»˜ ì „í™”ì™”ë‹¤. ì‹œí—˜ì¹˜ë‹¤ ì»¨ë‹ì„ í–ˆë‹¤ê³ ?! ë‚´ê°€ ë„ ê·¸ë ‡ê²Œ ê°€ë¥´ì³¤ë‹ˆ!!", color: "#ff6b6b" },
        { speaker: "ë‚˜", text: "ì£„ì†¡í•´ìš”... ê³µë¶€ë¥¼ ì•ˆ í•´ì„œ ì ìˆ˜ë¼ë„ ì˜ ë°›ê³  ì‹¶ì–´ì„œ ê·¸ë§Œ...", color: "#aaa" },
        { speaker: "ë‚˜", text: "ì •ë§ ì˜ëª»í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œëŠ” ë¶€ì •í–‰ìœ„ ì•ˆ í• ê²Œìš”...", color: "#4CAF50" }
      ],
      fail_score: [
        { speaker: "ì—„ë§ˆ", text: "ì„±ì í‘œ ë‚˜ì™”ë‹¤. ì ìˆ˜ê°€ ì´ê²Œ ë­ë‹ˆ?", color: "#ff6b6b" },
        { speaker: "ë‚˜", text: "ê·¸ê²Œ... ë‹µì„ ì¢€ ì˜ëª» ì ì–´ì„œ...", color: "#4488ff" },
        { speaker: "ì—„ë§ˆ", text: "ë„ˆ ë§Œì  ë°›ëŠ”ë‹¤ê³  í–ˆì–ì•„! ë‹¹ë¶„ê°„ ìš©ëˆì€ ì—†ë‹¤!", color: "#ff6b6b" }
      ],
      success: [
        { speaker: "ì—„ë§ˆ", text: "ì„¸ìƒì—! ìš°ë¦¬ ì•„ë“¤ì´ ì‹œí—˜ ë§Œì  ë°›ì•˜ë„¤!", color: "#ff6b6b" },
        { speaker: "ë‚˜", text: "ì™€! ì§„ì§œìš”? (íœ´... ì™„ë²½í•˜ê²Œ ì„±ê³µí–ˆë‹¤!)", color: "#4488ff" },
        { speaker: "ì—„ë§ˆ", text: "ì •ë§ ìë‘ìŠ¤ëŸ½ë‹¤! ì˜¤ëŠ˜ ì €ë…ì€ ë„¤ê°€ ì¢‹ì•„í•˜ëŠ” ê±¸ë¡œ ë¨¹ì!", color: "#ff6b6b" },
        { speaker: "ë‚˜", text: "ì•—ì‹¸! ì—„ë§ˆ ì‚¬ë‘í•´ìš”!", color: "#4488ff" }
      ]
    };

    // [ìˆ˜ì •] ë¬¸ì œ í’€ ì—…ë°ì´íŠ¸ (ì˜¤íƒ€ ìˆ˜ì • ë° ëª©ë¡ ë³€ê²½)
    const PROBLEM_POOL = [
      "orthographic projection", "viewport transformation", "MeshLambertMaterial", "z value interpolation",
      "world coordinate system", "quaternion multiplication", "Phong reflection model", "ambient reflection and diffuse reflection",
      "element array buffer", "keyframe interpolation", "FFmpeg video", "MeshPhongMaterial", "gl.DEPTH_BUFFER_BIT",
      "indirect illumination", "perspective transformation", "UVN coordinate system", "gl.ELEMENT_ARRAY_BUFFER",
      "homogeneous coordinate", "parallel projection", "aliasing"
    ];

    let currentCorrectAnswers = [];

    const game = {
      scene: null, camera: null, renderer: null,
      schoolGroup: null, homeGroup: null,   
      player: {
        position: new THREE.Vector3(0, 1.5, 0), seat: { row: 2, col: 3 },
        eyeYBase: 1.5, eyeYStand: 2.05, eyeYSmooth: 1.5, standSpeed: 8.5
      },
      npcs: [], isCheating: false, isWriting: false, timeLeft: 80, state: 'loading', 
      currentDialogueSet: [], dialogueIndex: 0, charIndex: 0, typingInterval: null, onDialogueEnd: null, 
      warnings: 0, maxWarnings: 3, isInvincible: false, invincibleTime: 3.0, currentInvincibleTime: 0,
      clock: new THREE.Clock(), mouse: { x: Math.PI, y: 0, sensitivity: 0.002 }, mouseNDC: { x: 0, y: 0 }, 
      keys: { w: false, a: false, s: false, d: false }, userAnswers: [],
      homeCharacters: { mom: null, son: null },
      students: [],
      speechIndicator: null 
    };

    const BASE_YAW = Math.PI;
    const ROOM_W = 25; const ROOM_D = 30; const WALL_H = 6;
    const FRONT_Z = ROOM_D / 2; const BACK_Z = -ROOM_D / 2;
    const LEFT_X = -ROOM_W / 2; const RIGHT_X = ROOM_W / 2;
    const TEACHER_Z = FRONT_Z - 3.0;
    const DESK_ROWS = 4; DESK_COLS = 5; GAP_X = 4.2; GAP_Z = 4.8; START_Z = 8.0; START_X = -( (DESK_COLS - 1) * GAP_X ) / 2;

    function init() {
      setupRandomAnswers();
      const cheatContent = document.getElementById('cheatContent');
      currentCorrectAnswers.forEach((ans, idx) => {
        const p = document.createElement('div'); p.style.marginBottom = "8px"; p.textContent = `${idx + 1}. ${ans}`; cheatContent.appendChild(p);
      });

      const container = document.getElementById('gameContainer');
      game.scene = new THREE.Scene();
      game.scene.background = new THREE.Color(0xf0f0f0);
      game.scene.fog = new THREE.Fog(0xf0f0f0, 8, 28);
      game.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
      game.camera.rotation.order = 'YXZ';
      game.renderer = new THREE.WebGLRenderer({ antialias: true });
      game.renderer.setSize(window.innerWidth, window.innerHeight);
      game.renderer.shadowMap.enabled = true;
      container.appendChild(game.renderer.domElement);

      game.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(5, 10, 5); dir.castShadow = true; game.scene.add(dir);

      game.schoolGroup = new THREE.Group(); game.homeGroup = new THREE.Group();
      game.scene.add(game.schoolGroup); game.scene.add(game.homeGroup);

      createSchoolEnvironment(); createClassroom(); createNPCs(); createHome(); 

      setupInputs();
      setTimeout(() => {
        document.getElementById('loadingScreen').classList.add('hidden');
        switchScene('home');
        startDialogue(INTRO_DIALOGUES, () => { showInstructions(); }, 'bg-home');
      }, 500);
      animate();
    }

    function setupRandomAnswers() {
      const shuffled = [...PROBLEM_POOL].sort(() => 0.5 - Math.random());
      currentCorrectAnswers = shuffled.slice(0, 5);
    }

    function switchScene(mode) {
      if(mode === 'home') {
        game.schoolGroup.visible = false; game.homeGroup.visible = true;
        game.scene.background = new THREE.Color(0xffe0b2); game.scene.fog = null;
        game.camera.position.set(0, 3, 11); 
      } else {
        game.schoolGroup.visible = true; game.homeGroup.visible = false;
        game.scene.background = new THREE.Color(0xf0f0f0); game.scene.fog = new THREE.Fog(0xf0f0f0, 8, 28);
      }
    }

    function startDialogue(dialogueSet, onEndCallback, bgClass) {
      game.state = 'dialogue'; game.currentDialogueSet = dialogueSet; game.dialogueIndex = 0; game.onDialogueEnd = onEndCallback;
      if (bgClass === 'bg-home') switchScene('home'); else if (bgClass === 'bg-school') switchScene('school');
      const screen = document.getElementById('dialogueScreen');
      screen.className = ''; if (bgClass) screen.classList.add(bgClass);
      screen.style.display = 'flex'; screen.style.opacity = 1;
      document.getElementById('dialogueBox').style.opacity = 1;
      document.getElementById('hud').style.display = 'none'; document.getElementById('controls').style.display = 'none';
      document.getElementById('cheatSheet').style.display = 'none'; document.exitPointerLock();
      showDialogue(0);
    }

    function showDialogue(index) {
      if (index >= game.currentDialogueSet.length) { if (game.onDialogueEnd) game.onDialogueEnd(); return; }
      game.dialogueIndex = index; const data = game.currentDialogueSet[index];
      const nameEl = document.getElementById('speakerName'); const textEl = document.getElementById('dialogueText');
      nameEl.textContent = data.speaker; nameEl.style.color = data.color; textEl.textContent = "";
      game.charIndex = 0; if (game.typingInterval) clearInterval(game.typingInterval);
      game.typingInterval = setInterval(() => {
        textEl.textContent += data.text.charAt(game.charIndex); game.charIndex++;
        if (game.charIndex >= data.text.length) { clearInterval(game.typingInterval); game.typingInterval = null; }
      }, 30); 
    }

    function nextDialogue() {
      if (game.typingInterval) {
        clearInterval(game.typingInterval); game.typingInterval = null;
        document.getElementById('dialogueText').textContent = game.currentDialogueSet[game.dialogueIndex].text;
      } else { showDialogue(game.dialogueIndex + 1); }
    }

    function showInstructions() {
      document.getElementById('dialogueScreen').style.display = 'none'; document.getElementById('instructionScreen').style.display = 'flex';
      switchScene('school');
    }

    function closeInstructions() { document.getElementById('instructionScreen').style.display = 'none'; startGameplay(); }

    function startGameplay() {
      game.state = 'playing'; switchScene('school');
      document.getElementById('dialogueScreen').style.display = 'none'; 
      document.getElementById('hud').style.display = 'block'; document.getElementById('controls').style.display = 'block';
      const mySeat = game.player.position; game.camera.position.copy(mySeat);
      game.mouse.x = Math.PI; game.mouse.y = 0; game.renderer.domElement.requestPointerLock();
    }

    function showGradingScreen() {
      game.state = 'grading'; document.exitPointerLock();
      document.getElementById('answerSheet').style.display = 'none'; document.getElementById('hud').style.display = 'none';
      document.getElementById('controls').style.display = 'none'; document.getElementById('gradingScreen').style.display = 'flex';
      const rawText = document.getElementById('answerInput').value;
      game.userAnswers = rawText.split('\n').map(l => l.trim()).filter(l => l.length > 0);
      const correctListDiv = document.getElementById('correctList'); const myListDiv = document.getElementById('myList');
      correctListDiv.innerHTML = ''; myListDiv.innerHTML = ''; let correctCount = 0;
      for(let i=0; i<currentCorrectAnswers.length; i++) {
        const correctItem = document.createElement('div'); correctItem.className = 'grade-item correct';
        correctItem.textContent = `${i+1}. ${currentCorrectAnswers[i]}`; correctListDiv.appendChild(correctItem);
        const myAns = game.userAnswers[i] || "(ë¯¸ì‘ì„±)"; const isMatch = (myAns === currentCorrectAnswers[i]);
        if (isMatch) correctCount++;
        const myItem = document.createElement('div'); myItem.className = isMatch ? 'grade-item correct' : 'grade-item wrong';
        myItem.textContent = `${i+1}. ${myAns}`; if (!isMatch) myItem.textContent += " (X)"; myListDiv.appendChild(myItem);
      }
      const score = correctCount * 20; const scoreDiv = document.getElementById('gradingScoreDisplay');
      scoreDiv.textContent = `ì ìˆ˜: ${score}ì  / 100ì `; scoreDiv.style.color = score === 100 ? '#4CAF50' : '#f44336';
    }

    function finishGrading() {
      document.getElementById('gradingScreen').style.display = 'none';
      let correctCount = 0; for(let i=0; i<currentCorrectAnswers.length; i++) { if(game.userAnswers[i] === currentCorrectAnswers[i]) correctCount++; }
      if(correctCount === currentCorrectAnswers.length) startDialogue(ENDING_SCENARIOS.success, triggerHappyEndOverlay, 'bg-home');
      else startDialogue(ENDING_SCENARIOS.fail_score, triggerHappyEndOverlay, 'bg-home');
    }

    function triggerHappyEndOverlay() {
      document.getElementById('dialogueBox').style.opacity = 0;
      document.getElementById('statusMsg').style.opacity = 0;
      document.getElementById('statusMsg').textContent = "";
      
      const theEndScreen = document.getElementById('theEndScreen'); document.getElementById('theEndSub').textContent = ""; 
      theEndScreen.style.display = 'flex'; theEndScreen.style.background = 'transparent'; 
      setTimeout(() => { theEndScreen.style.opacity = 1; }, 100); game.state = 'finished';
    }

    function triggerCaughtEnding() {
      document.getElementById('dialogueScreen').style.opacity = 0; 
      document.getElementById('statusMsg').style.opacity = 0;
      document.getElementById('statusMsg').textContent = "";

      setTimeout(() => {
        document.getElementById('dialogueScreen').style.display = 'none';
        const theEndScreen = document.getElementById('theEndScreen'); document.getElementById('theEndSub').textContent = "ì—¬ëŸ¬ë¶„ ë¶€ì •í–‰ìœ„ë¥¼ í•˜ì§€ ë§™ì‹œë‹¤";
        theEndScreen.style.display = 'flex'; theEndScreen.style.background = '#000'; 
        setTimeout(() => { theEndScreen.style.opacity = 1; }, 100); game.state = 'finished'; 
      }, 500);
    }

    function handleTimeUp() {
      game.state = 'time_up'; 
      const msgEl = document.getElementById('timeUpMessage');
      msgEl.style.display = 'block';
      setTimeout(() => {
        msgEl.style.display = 'none';
        showGradingScreen();
      }, 2000);
    }

    function createSchoolEnvironment() {
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_W, ROOM_D), new THREE.MeshStandardMaterial({ color: 0xd4a574, roughness: 0.85 }));
      floor.rotation.x = -Math.PI / 2; floor.receiveShadow = true; game.schoolGroup.add(floor);
      const wallMat = new THREE.MeshStandardMaterial({ color: 0xe8e8e8 });
      const makeWall = (w, h, d, x, y, z) => { const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), wallMat); mesh.position.set(x, y, z); game.schoolGroup.add(mesh); };
      makeWall(ROOM_W, WALL_H, 0.2, 0, WALL_H/2, FRONT_Z); makeWall(ROOM_W, WALL_H, 0.2, 0, WALL_H/2, BACK_Z);
      makeWall(0.2, WALL_H, ROOM_D, LEFT_X, WALL_H/2, 0); makeWall(0.2, WALL_H, ROOM_D, RIGHT_X, WALL_H/2, 0);
      const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_W, ROOM_D), new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide }));
      ceiling.rotation.x = Math.PI / 2; ceiling.position.y = WALL_H; game.schoolGroup.add(ceiling);
      const bb = new THREE.Mesh(new THREE.BoxGeometry(8, 3, 0.1), new THREE.MeshStandardMaterial({ color: 0x1a4d2e })); bb.position.set(0, 3, FRONT_Z - 0.2); game.schoolGroup.add(bb);
      const pd = new THREE.Mesh(new THREE.BoxGeometry(8.5, 0.35, 2.3), new THREE.MeshStandardMaterial({ color: 0x8b6f47 })); pd.position.set(0, 0.18, FRONT_Z - 2.0); game.schoolGroup.add(pd);
      
      const doorGeo = new THREE.BoxGeometry(0.2, 4.5, 2.5); const doorMat = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
      const d1 = new THREE.Mesh(doorGeo, doorMat); d1.position.set(RIGHT_X - 0.1, 2.25, FRONT_Z - 5); game.schoolGroup.add(d1);
      const d2 = new THREE.Mesh(doorGeo, doorMat); d2.position.set(RIGHT_X - 0.1, 2.25, BACK_Z + 5); game.schoolGroup.add(d2);

      const ledGeo = new THREE.BoxGeometry(2.5, 0.05, 0.5); const ledMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x555555 });
      for (let z = FRONT_Z - 4; z > BACK_Z + 4; z -= 7) { for (let x = LEFT_X + 5; x < RIGHT_X - 5; x += 7) { const led = new THREE.Mesh(ledGeo, ledMat); led.position.set(x, WALL_H - 0.025, z); game.schoolGroup.add(led); }}
    }

    function createIndicator() {
        const group = new THREE.Group();
        const dotGeo = new THREE.SphereGeometry(0.08, 8, 8);
        const dotMat = new THREE.MeshBasicMaterial({ color: 0x000000 }); 
        for(let i=-1; i<=1; i++) {
            const dot = new THREE.Mesh(dotGeo, dotMat);
            dot.position.x = i * 0.3; 
            group.add(dot);
        }
        group.visible = false;
        return group;
    }

    function createHome() {
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(24, 17), new THREE.MeshStandardMaterial({ color: 0x8d6e63 })); floor.rotation.x = -Math.PI / 2; game.homeGroup.add(floor);
      const wallMat = new THREE.MeshStandardMaterial({ color: 0xfff3e0 });
      const backWall = new THREE.Mesh(new THREE.BoxGeometry(24, 9, 0.5), wallMat); backWall.position.set(0, 4.5, -8.5); game.homeGroup.add(backWall);
      
      const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, 9, 17), wallMat); leftWall.position.set(-12, 4.5, 0); game.homeGroup.add(leftWall);
      const rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, 9, 17), wallMat); rightWall.position.set(12, 4.5, 0); game.homeGroup.add(rightWall);
      const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(24, 17), new THREE.MeshStandardMaterial({ color: 0xffffff })); ceiling.rotation.x = Math.PI / 2; ceiling.position.y = 9; game.homeGroup.add(ceiling);

      const frontSideWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, 9, 3.5), wallMat); frontSideWall.position.set(-12, 4.5, 6.75); game.homeGroup.add(frontSideWall);
      const backSideWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, 9, 3.5), wallMat); backSideWall.position.set(-12, 4.5, -6.75); game.homeGroup.add(backSideWall);

      const door = new THREE.Mesh(new THREE.BoxGeometry(0.2, 7, 4), new THREE.MeshStandardMaterial({ color: 0x3e2723 }));
      door.position.set(11.8, 3.5, 0); game.homeGroup.add(door);
      const doorKnob = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshStandardMaterial({ color: 0xffd700 }));
      doorKnob.position.set(11.6, 3.5, 1.5); game.homeGroup.add(doorKnob);

      const centerTable = new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 2), new THREE.MeshStandardMaterial({ color: 0x5d4037 })); centerTable.position.set(0, 0.25, -1); centerTable.scale.set(1.2, 1.2, 1.2); game.homeGroup.add(centerTable);
      const tvStand = new THREE.Mesh(new THREE.BoxGeometry(6, 0.8, 1.5), new THREE.MeshStandardMaterial({ color: 0x3e2723 })); tvStand.position.set(0, 0.4, -8.0); tvStand.scale.set(1.2, 1.2, 1.2); game.homeGroup.add(tvStand);
      const tv = new THREE.Mesh(new THREE.BoxGeometry(5, 3, 0.2), new THREE.MeshStandardMaterial({ color: 0x111111 })); tv.position.set(0, 2.5, -8.0); tv.scale.set(1.2, 1.2, 1.2); game.homeGroup.add(tv);

      const sofaGroup = new THREE.Group(); const beigeMat = new THREE.MeshStandardMaterial({ color: 0xeed9c4 });
      const sofaBase = new THREE.Mesh(new THREE.BoxGeometry(8, 1, 2.5), beigeMat); sofaBase.position.y = 0.5; sofaGroup.add(sofaBase);
      const sofaBack = new THREE.Mesh(new THREE.BoxGeometry(8, 2, 0.5), beigeMat); sofaBack.position.set(0, 1.5, 1); sofaGroup.add(sofaBack);
      const sofaL = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 2.5), beigeMat); sofaL.position.set(-3.5, 1, 0); sofaGroup.add(sofaL);
      const sofaR = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 2.5), beigeMat); sofaR.position.set(3.5, 1, 0); sofaGroup.add(sofaR);
      sofaGroup.position.set(0, 0, 5.5); sofaGroup.scale.set(0.72, 0.72, 0.72); game.homeGroup.add(sofaGroup);

      const studyDeskGroup = new THREE.Group();
      const studyDesk = new THREE.Mesh(new THREE.BoxGeometry(4, 0.1, 2), new THREE.MeshStandardMaterial({ color: 0x795548 }));
      studyDesk.position.y = 1.5; studyDeskGroup.add(studyDesk);
      const studyLeg1 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.5, 1.8), new THREE.MeshStandardMaterial({ color: 0x5d4037 }));
      studyLeg1.position.set(-1.8, 0.75, 0); studyDeskGroup.add(studyLeg1);
      const studyLeg2 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.5, 1.8), new THREE.MeshStandardMaterial({ color: 0x5d4037 }));
      studyLeg2.position.set(1.8, 0.75, 0); studyDeskGroup.add(studyLeg2);
      studyDeskGroup.position.set(-8, 0, -7.5);
      studyDeskGroup.scale.set(1.2, 1.2, 1.2); game.homeGroup.add(studyDeskGroup);

      const studyChair = createChair(1.8, 0x999999); 
      studyChair.position.set(-8, 0, -6.0); 
      studyChair.rotation.y = Math.PI; 
      game.homeGroup.add(studyChair);

      const artCanvas = document.createElement('canvas'); artCanvas.width = 512; artCanvas.height = 512;
      const ctx = artCanvas.getContext('2d');
      ctx.fillStyle = '#f0f0f0'; ctx.fillRect(0,0,512,512);
      ctx.strokeStyle = '#FF6347'; ctx.lineWidth = 10;
      ctx.beginPath(); ctx.moveTo(50, 50); ctx.lineTo(462, 462); ctx.stroke();
      ctx.strokeStyle = '#4682B4';
      ctx.beginPath(); ctx.moveTo(462, 50); ctx.lineTo(50, 462); ctx.stroke();
      ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(256, 256, 80, 0, Math.PI*2); ctx.fill();
      const artTex = new THREE.CanvasTexture(artCanvas); const artMat = new THREE.MeshBasicMaterial({ map: artTex }); const frameMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
      const newFrameGroup = new THREE.Group();
      const frameMesh = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 0.2), frameMat);
      const pictureMesh = new THREE.Mesh(new THREE.PlaneGeometry(3.8, 2.8), artMat); pictureMesh.position.z = 0.11; 
      newFrameGroup.add(frameMesh); newFrameGroup.add(pictureMesh);
      newFrameGroup.position.set(11.9, 5, 0); newFrameGroup.rotation.y = -Math.PI / 2; newFrameGroup.scale.set(1.2, 1.2, 1.2);
      game.homeGroup.add(newFrameGroup);

      const HOME_PERSON_SCALE = 1.82;
      const mom = createPerson(0x9c27b0, 'mom'); 
      mom.position.set(-3.5, 0, 0); mom.rotation.y = Math.PI / 2; 
      mom.scale.set(HOME_PERSON_SCALE, HOME_PERSON_SCALE, HOME_PERSON_SCALE);
      game.homeGroup.add(mom); game.homeCharacters.mom = mom; 

      const son = createPerson(0x4488ff, 'student_stand'); 
      son.position.set(3.5, 0, 0); son.rotation.y = -Math.PI / 2;
      son.scale.set(HOME_PERSON_SCALE, HOME_PERSON_SCALE, HOME_PERSON_SCALE);
      game.homeGroup.add(son); game.homeCharacters.son = son; 

      game.speechIndicator = createIndicator();
      game.homeGroup.add(game.speechIndicator);
    }

    function createChair(scaleFactor, colorHex) {
        const chairGroup = new THREE.Group();
        const chairMat = new THREE.MeshStandardMaterial({ color: colorHex });
        const seat = new THREE.Mesh(new THREE.BoxGeometry(0.85, 0.1, 0.85), chairMat); seat.position.y = 0.45; chairGroup.add(seat);
        const back = new THREE.Mesh(new THREE.BoxGeometry(0.85, 0.5, 0.1), chairMat); back.position.set(0, 0.7, -0.35); chairGroup.add(back);
        const legGeo = new THREE.BoxGeometry(0.1, 0.45, 0.1);
        [[-0.35, 0.225, -0.35], [0.35, 0.225, -0.35], [-0.35, 0.225, 0.35], [0.35, 0.225, 0.35]].forEach(pos => {
            const leg = new THREE.Mesh(legGeo, chairMat); leg.position.set(...pos); chairGroup.add(leg);
        });
        chairGroup.scale.set(scaleFactor, scaleFactor, scaleFactor);
        return chairGroup;
    }

    function createClassroom() {
      const scale = 1.21; 
      for (let r = 0; r < DESK_ROWS; r++) {
        for (let c = 0; c < DESK_COLS; c++) {
          const x = START_X + c * GAP_X; const z = START_Z - r * GAP_Z;
          const desk = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.12, 1.05), new THREE.MeshStandardMaterial({ color: 0xa67c52 })); desk.position.set(x, 0.72, z); desk.scale.set(scale, scale, scale); desk.castShadow = true; game.schoolGroup.add(desk);
          const paper = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.01, 0.7), new THREE.MeshStandardMaterial({ color: 0xffffff })); paper.position.set(x, 0.79, z); paper.scale.set(scale, scale, scale); paper.receiveShadow = true; game.schoolGroup.add(paper);
          
          const chairGroup = createChair(scale, 0x4a4a4a);
          chairGroup.position.set(x, 0, z - 0.75); game.schoolGroup.add(chairGroup);

          if (r === 1 && c === 2) {
             game.player.position.set(x, game.player.eyeYBase, z - 0.4); game.player.eyeYSmooth = game.player.eyeYBase;
             const playerModel = createPerson(0xff6b6b, 'student'); playerModel.position.set(x, 0, z - 0.75); 
             playerModel.traverse(child => { if (child.isMesh) { child.material.transparent = true; child.material.opacity = 0; } });
             game.schoolGroup.add(playerModel);
          } else {
            const s = createPerson([0x4488ff, 0xff6b6b, 0x51cf66, 0xffd43b][Math.floor(Math.random()*4)], 'student');
            s.position.set(x, 0, z - 0.75); s.scale.set(scale, scale, scale); game.schoolGroup.add(s);
            game.students.push(s); 
          }
        }
      }
    }

    function createPerson(shirtColor, type) {
      const group = new THREE.Group();
      const skinColors = [0xffdbac, 0xf1c27d, 0xe0ac69];
      let skinColor = (type === 'mom') ? 0xffdbac : skinColors[Math.floor(Math.random() * skinColors.length)];
      const hairColor = (type === 'mom') ? 0x5d4037 : [0x090806, 0x3b3024][Math.floor(Math.random()*2)];

      const shirtMat = new THREE.MeshStandardMaterial({ color: shirtColor });
      const pantsMat = new THREE.MeshStandardMaterial({ color: 0x333333 }); 
      const skinMat = new THREE.MeshStandardMaterial({ color: skinColor, polygonOffset: true, polygonOffsetFactor: -1.0, polygonOffsetUnits: -1.0 });
      const hairMat = new THREE.MeshStandardMaterial({ color: hairColor, polygonOffset: true, polygonOffsetFactor: -1.0, polygonOffsetUnits: -1.0 });
      const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000, polygonOffset: true, polygonOffsetFactor: -2.0, polygonOffsetUnits: -2.0 }); 

      const isSitting = (type === 'student');

      const head = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.32, 0.3), skinMat);
      head.position.y = isSitting ? 1.35 : 1.7;
      head.name = 'head'; 
      group.add(head);

      const hair = new THREE.Mesh(new THREE.BoxGeometry(0.32, 0.15, 0.32), hairMat);
      hair.position.y = 0.18; 
      head.add(hair); 
      
      const eyeGeo = new THREE.CircleGeometry(0.02, 8); 
      const leftEye = new THREE.Mesh(eyeGeo, eyeMat); leftEye.position.set(-0.08, 0.05, 0.151); head.add(leftEye);
      const rightEye = new THREE.Mesh(eyeGeo, eyeMat); rightEye.position.set(0.08, 0.05, 0.151); head.add(rightEye);

      if (isSitting) {
        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.46, 0.6, 0.25), shirtMat); torso.position.y = 0.9; group.add(torso);
        const hips = new THREE.Mesh(new THREE.BoxGeometry(0.46, 0.2, 0.4), pantsMat); hips.position.y = 0.5; group.add(hips);
        const legGeo = new THREE.BoxGeometry(0.18, 0.18, 0.5);
        const lLeg = new THREE.Mesh(legGeo, pantsMat); lLeg.position.set(-0.12, 0.5, 0.3); group.add(lLeg);
        const rLeg = new THREE.Mesh(legGeo, pantsMat); rLeg.position.set(0.12, 0.5, 0.3); group.add(rLeg);
        const calfGeo = new THREE.BoxGeometry(0.18, 0.5, 0.18);
        const lCalf = new THREE.Mesh(calfGeo, pantsMat); lCalf.position.set(-0.12, 0.25, 0.5); group.add(lCalf);
        const rCalf = new THREE.Mesh(calfGeo, pantsMat); rCalf.position.set(0.12, 0.25, 0.5); group.add(rCalf);

        // [ìˆ˜ì •] ì–´ê¹¨ ë†’ì´ë¥¼ 1.2ë¡œ ìƒí–¥í•˜ì—¬ íŒ”ì´ ì±…ìƒë³´ë‹¤ ë†’ê²Œ ì‹œì‘
        const armGeo = new THREE.BoxGeometry(0.14, 0.45, 0.14); armGeo.translate(0, -0.225, 0);
        const lArm = new THREE.Mesh(armGeo, shirtMat); 
        lArm.position.set(0.24, 1.2, 0.05); // ì™¼ìª½ íŒ” (ê³ ì •)
        lArm.rotation.x = -0.3; lArm.name = 'leftUpperArm'; group.add(lArm);
        
        const rArm = new THREE.Mesh(armGeo, shirtMat); 
        rArm.position.set(-0.24, 1.2, 0.05); // ì˜¤ë¥¸ìª½ íŒ” (ì›€ì§ì„)
        rArm.rotation.x = -0.3; rArm.name = 'rightUpperArm'; group.add(rArm);
        
        const forearmGeo = new THREE.BoxGeometry(0.12, 0.4, 0.12); forearmGeo.translate(0, -0.2, 0);
        const lForearm = new THREE.Mesh(forearmGeo, skinMat); lForearm.position.set(0, -0.45, 0); lForearm.rotation.x = -0.5; lForearm.name = 'leftForearm'; lArm.add(lForearm);
        const rForearm = new THREE.Mesh(forearmGeo, skinMat); rForearm.position.set(0, -0.45, 0); rForearm.rotation.x = -0.5; rForearm.name = 'rightForearm'; rArm.add(rForearm);

        const penGeo = new THREE.CylinderGeometry(0.008, 0.008, 0.25, 8);
        penGeo.rotateX(Math.PI / 2);
        const penMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const pen = new THREE.Mesh(penGeo, penMat);
        pen.position.set(0.0, -0.38, 0.05); 
        pen.rotation.set(0.5, 0, 0.2);
        
        // íœì„ ì˜¤ë¥¸ìª½ íŒ”(rForearm)ì— ë¶€ì°©
        rForearm.add(pen); 

      } else {
        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.48, 0.7, 0.28), shirtMat); torso.position.y = 1.25; group.add(torso);
        const legGeo = new THREE.BoxGeometry(0.2, 0.9, 0.2);
        const lLeg = new THREE.Mesh(legGeo, pantsMat); lLeg.position.set(-0.13, 0.45, 0); group.add(lLeg);
        const rLeg = new THREE.Mesh(legGeo, pantsMat); rLeg.position.set(0.13, 0.45, 0); group.add(rLeg);
        const armGeo = new THREE.BoxGeometry(0.16, 0.75, 0.16);
        const lArm = new THREE.Mesh(armGeo, shirtMat); lArm.position.set(-0.34, 1.2, 0); group.add(lArm);
        const rArm = new THREE.Mesh(armGeo, shirtMat); rArm.position.set(0.34, 1.2, 0); group.add(rArm);
      }
      return group;
    }

    function createNPCs() {
      game.npcs.push(createNPC(0, TEACHER_Z, 0x2c3e50, 'teacher'));
      game.npcs.push(createNPC(LEFT_X + 2.5, 1.5, 0x34495e, 'invigilator'));
      game.npcs.push(createNPC(RIGHT_X - 2.5, 1.5, 0x34495e, 'invigilator'));
    }

    function createNPC(x, z, color, role) {
      const group = new THREE.Group();
      const person = createPerson(color, 'invigilator'); 
      if(role === 'teacher') person.scale.set(1.1 * 1.21, 1.1 * 1.21, 1.1 * 1.21); else person.scale.set(1.21, 1.21, 1.21);
      group.add(person);
      const isTeacher = role === 'teacher';
      const visionDistance = isTeacher ? 10.4 : 12; const visionRadius = isTeacher ? 4.0 : 4.8; const eyeHeight = isTeacher ? 2.0 : 1.75; const visionAngle = isTeacher ? Math.PI / 5.5 : Math.PI / 4;
      const coneGeom = new THREE.ConeGeometry(visionRadius, visionDistance, 32, 1, true); coneGeom.translate(0, -visionDistance / 2, 0);
      const coneMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
      const vision = new THREE.Mesh(coneGeom, coneMat); vision.rotation.x = -Math.PI / 2; vision.position.y = eyeHeight; group.add(vision);
      group.position.set(x, 0, z); group.rotation.y = BASE_YAW; game.schoolGroup.add(group);
      return { role, group, eyeHeight, visionDistance, visionAngle, podiumLeftX: -3.5, podiumRightX: 3.5, moveSpeed: 1.6 + Math.random(), moveDir: Math.random() < 0.5 ? 1 : -1, scanTime: Math.random() * 10, angle: Math.random() * 10, rotationSpeed: 0.5 };
    }

    function setupInputs() {
      document.addEventListener('keydown', (e) => {
        if (game.state === 'dialogue') { if (e.code === 'Enter') { nextDialogue(); return; } if (e.code === 'KeyW') game.keys.w = true; if (e.code === 'KeyA') game.keys.a = true; if (e.code === 'KeyS') game.keys.s = true; if (e.code === 'KeyD') game.keys.d = true; }
        if (e.code === 'Space' && game.state === 'playing' && !game.isWriting) { game.isCheating = true; document.getElementById('cheatSheet').style.display = 'block'; }
      });
      document.addEventListener('keyup', (e) => {
        if (game.state === 'dialogue') { if (e.code === 'KeyW') game.keys.w = false; if (e.code === 'KeyA') game.keys.a = false; if (e.code === 'KeyS') game.keys.s = false; if (e.code === 'KeyD') game.keys.d = false; }
        if (e.code === 'Space') { game.isCheating = false; document.getElementById('cheatSheet').style.display = 'none'; }
      });
      window.addEventListener('keydown', (e) => {
        if (game.state !== 'playing') return;
        if (e.code === 'Digit9') { e.preventDefault(); if (!game.isWriting && !game.isCheating) toggleWritingMode(true); }
        if (e.code === 'Digit0' || e.code === 'Escape') { if (game.isWriting) toggleWritingMode(false); }
      });
      document.addEventListener('mousemove', (e) => {
        game.mouseNDC.x = (e.clientX / window.innerWidth) * 2 - 1; game.mouseNDC.y = -(e.clientY / window.innerHeight) * 2 + 1;
        if (game.state !== 'playing' || game.isWriting) return; if (document.pointerLockElement !== game.renderer.domElement) return;
        game.mouse.x += e.movementX * game.mouse.sensitivity; game.mouse.y += e.movementY * game.mouse.sensitivity; game.mouse.y = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, game.mouse.y));
      });
      game.renderer.domElement.addEventListener('click', () => { if (game.state === 'dialogue') { nextDialogue(); return; } if (game.state === 'playing' && !game.isWriting) game.renderer.domElement.requestPointerLock(); });
      document.getElementById('answerInput').addEventListener('keydown', (e) => { e.stopPropagation(); if (e.code === 'Digit0' || e.code === 'Escape') { e.preventDefault(); toggleWritingMode(false); return; } });
    }

    function toggleWritingMode(on) {
      game.isWriting = on; const sheet = document.getElementById('answerSheet'); const input = document.getElementById('answerInput'); const msg = document.getElementById('statusMsg');
      if (on) { document.exitPointerLock(); sheet.style.display = 'flex'; input.focus(); game.mouse.x = Math.PI; game.mouse.y = Math.PI / 2.5; msg.textContent = "âœï¸ ë‹µì•ˆ ì‘ì„± ì¤‘... (ì„ ìƒë‹˜ê»˜ ì•ˆì „)"; msg.style.opacity = 1; } else { sheet.style.display = 'none'; game.renderer.domElement.requestPointerLock(); msg.style.opacity = 0; }
    }

    function updateTeacher(npc, delta) {
      npc.group.position.x += npc.moveDir * npc.moveSpeed * delta;
      if (npc.group.position.x < npc.podiumLeftX) { npc.group.position.x = npc.podiumLeftX; npc.moveDir = 1; } if (npc.group.position.x > npc.podiumRightX) { npc.group.position.x = npc.podiumRightX; npc.moveDir = -1; }
      npc.scanTime += 1.6 * delta; npc.group.rotation.y = BASE_YAW + Math.sin(npc.scanTime) * 0.42;
    }

    function updateInvigilator(npc, delta) {
      npc.angle += npc.rotationSpeed * delta; const swing = Math.abs(Math.sin(npc.angle) * 0.7); 
      if (npc.group.position.x < 0) npc.group.rotation.y = BASE_YAW - swing; else npc.group.rotation.y = BASE_YAW + swing;
    }

    function handleWarning() {
      if (game.isInvincible) return; game.warnings++;
      const warningArea = document.getElementById('warningArea'); const card = document.createElement('div'); card.className = 'yellow-card'; warningArea.appendChild(card);
      const overlay = document.getElementById('damageOverlay'); overlay.style.opacity = 1; setTimeout(() => overlay.style.opacity = 0, 300);
      if (game.warnings >= game.maxWarnings) { game.isCheating = false; document.getElementById('cheatSheet').style.display = 'none'; startDialogue(ENDING_SCENARIOS.caught, triggerCaughtEnding, 'bg-spotlight'); return; }
      game.isInvincible = true; game.currentInvincibleTime = game.invincibleTime;
      const msg = document.getElementById('statusMsg'); msg.textContent = `âš ï¸ ê²½ê³ ! (${game.warnings}/3) - 3ì´ˆê°„ ì£¼ì˜í•˜ì„¸ìš”!`; msg.className = 'warning'; msg.style.opacity = 1; game.isCheating = false; document.getElementById('cheatSheet').style.display = 'none';
    }

    function animate() {
      requestAnimationFrame(animate); const delta = game.clock.getDelta(); const time = Date.now() * 0.001;

      if (game.state === 'dialogue') {
        if (game.homeGroup.visible) {
          const speaker = document.getElementById('speakerName').textContent;
          
          let activeChar = null;
          if (speaker === "ì—„ë§ˆ") activeChar = game.homeCharacters.mom;
          else if (speaker === "ë‚˜") activeChar = game.homeCharacters.son;

          if (activeChar && game.speechIndicator) {
              const headPos = new THREE.Vector3();
              activeChar.getObjectByName('head').getWorldPosition(headPos);
              game.speechIndicator.position.set(headPos.x, headPos.y + 0.9, headPos.z);
              game.speechIndicator.visible = true;
              game.speechIndicator.position.y += Math.sin(time * 8) * 0.05;
          } else if (game.speechIndicator) {
              game.speechIndicator.visible = false;
          }

          if (game.homeCharacters.mom && game.homeCharacters.son) {
            game.homeCharacters.mom.position.y = 0; game.homeCharacters.son.position.y = 0;
            if (speaker === "ì—„ë§ˆ") { game.homeCharacters.mom.position.y = Math.sin(time * 12) * 0.15; } else if (speaker === "ë‚˜") { game.homeCharacters.son.position.y = Math.sin(time * 12) * 0.15; }
          }
          const forward = new THREE.Vector3(); game.camera.getWorldDirection(forward); forward.y = 0; forward.normalize();
          const right = new THREE.Vector3(); right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();
          const moveSpeed = 5.0;
          if (game.keys.w) game.camera.position.addScaledVector(forward, moveSpeed * delta); if (game.keys.s) game.camera.position.addScaledVector(forward, -moveSpeed * delta);
          if (game.keys.d) game.camera.position.addScaledVector(right, moveSpeed * delta); if (game.keys.a) game.camera.position.addScaledVector(right, -moveSpeed * delta);
          game.camera.position.x = Math.max(-10, Math.min(10, game.camera.position.x)); game.camera.position.z = Math.max(-10, Math.min(10, game.camera.position.z));
          const yaw = -game.mouseNDC.x * (Math.PI / 2); const pitch = game.mouseNDC.y * (Math.PI / 4); game.camera.rotation.set(pitch, yaw, 0, 'YXZ');
        } 
        else { const t = Date.now() * 0.0005; game.camera.position.x = Math.sin(t) * 15; game.camera.position.z = Math.cos(t) * 15 + 5; game.camera.lookAt(0, 0, 0); }
        game.renderer.render(game.scene, game.camera); return;
      }

      if (game.state !== 'playing') { if (game.state !== 'finished') game.renderer.render(game.scene, game.camera); return; }

      if (game.students.length > 0) {
        game.students.forEach((student, idx) => {
          const head = student.getObjectByName('head');
          const lArm = student.getObjectByName('leftUpperArm');
          const rArm = student.getObjectByName('rightUpperArm');
          const lForearm = student.getObjectByName('leftForearm');
          const rForearm = student.getObjectByName('rightForearm');

          if (head) {
             head.rotation.y = Math.sin(time * 0.8 + idx) * 0.5; 
             head.rotation.x = Math.abs(Math.sin(time * 0.5 + idx * 2)) * 0.4;
          }
          student.position.y = Math.sin(time * 3 + idx) * 0.008;

          if (lArm && lForearm) {
              lArm.rotation.x = -0.5; 
              lArm.rotation.z = 0;
              lForearm.rotation.x = -0.8;
          }
          // [ìˆ˜ì •] íŒ” ê°ë„ ì¬ì¡°ì • (ì±…ìƒê³¼ ê²¹ì¹˜ì§€ ì•Šë„ë¡)
          if (rArm && rForearm) {
              // ìƒë°•ì„ -0.75ë¡œ ì„¤ì •í•˜ì—¬ íŒ”ê¿ˆì¹˜ë¥¼ ì¡°ê¸ˆ ë“¬
              rArm.rotation.x = -0.75 + Math.sin(time * 3) * 0.005; 
              rArm.rotation.z = -Math.sin(time * 1.7 + idx) * 0.04;
              
              // í•˜ë°•ì„ -0.35ë¡œ ì„¤ì •í•˜ì—¬ ì†ëì´ ì±…ìƒì— ë‹¿ê²Œ ìœ ë„
              rForearm.rotation.x = -0.35 + Math.cos(time * 3) * 0.005;
              rForearm.rotation.y = -0.5 + Math.sin(time * 8) * 0.2; 
          }
        });
      }

      if (game.isInvincible) { game.currentInvincibleTime -= delta; if (game.currentInvincibleTime <= 0) { game.isInvincible = false; const msg = document.getElementById('statusMsg'); if (msg.className === 'warning') msg.style.opacity = 0; }}

      game.camera.rotation.y = -game.mouse.x; game.camera.rotation.x = -game.mouse.y;
      const targetEyeY = (game.isCheating && !game.isWriting) ? game.player.eyeYStand : game.player.eyeYBase;
      const t = 1 - Math.exp(-game.player.standSpeed * delta); game.player.eyeYSmooth += (targetEyeY - game.player.eyeYSmooth) * t; game.camera.position.y = game.player.eyeYSmooth;

      if (game.state === 'playing') {
          game.timeLeft -= delta; 
          document.getElementById('timeLeft').textContent = Math.ceil(Math.max(0, game.timeLeft));
          if (game.timeLeft <= 0) { handleTimeUp(); return; }
      }

      let caught = false;
      for (const npc of game.npcs) {
        if (npc.role === 'teacher') updateTeacher(npc, delta); else updateInvigilator(npc, delta);
        if (game.isCheating && !game.isWriting) {
          const npcPos = new THREE.Vector3(); npc.group.getWorldPosition(npcPos); npcPos.y = npc.eyeHeight;
          const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(npc.group.quaternion);
          const toPlayer = new THREE.Vector3().subVectors(game.player.position, npcPos).normalize();
          const distance = game.player.position.distanceTo(npcPos);
          const angle = Math.acos(THREE.MathUtils.clamp(forward.dot(toPlayer), -1, 1));
          if (angle < npc.visionAngle / 2 && distance < npc.visionDistance) caught = true;
        }
      }
      if (caught) handleWarning();
      game.renderer.render(game.scene, game.camera);
    }

    init();
  </script>
</body>
</html>