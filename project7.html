<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ì‹œí—˜ê¸°ê°„: ì™„ë²½í•œ ì»¨ë‹ (ìµœì¢… UI ì—…ë°ì´íŠ¸)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; font-family: 'Malgun Gothic', sans-serif; background: #000;}
    #gameContainer { width: 100vw; height: 100vh; }

    /* ë¡œë”© í™”ë©´ */
    #loadingScreen{
      position:absolute; inset:0; background:#000;
      display:flex; align-items:center; justify-content:center;
      color:#fff; font-size:24px; z-index:2000;
    }
    #loadingScreen.hidden{ display:none; }
    .loading-content{ text-align:center; }
    .loading-bar{ width:200px; height:4px; background:rgba(255,255,255,0.3); border-radius:2px; overflow:hidden; margin-top:20px; }
    .loading-progress{ width:100%; height:100%; background:#4CAF50; animation:loading 1.5s ease-in-out infinite; }
    @keyframes loading{ 0%,100%{ transform:translateX(-100%);} 50%{ transform:translateX(100%);} }

    /* ëŒ€í™”ì°½ í™”ë©´ */
    #dialogueScreen {
      position: absolute; inset: 0;
      z-index: 1500;
      display: none; flex-direction: column; justify-content: flex-end; align-items: center;
      padding-bottom: 50px;
      transition: background 0.5s ease-in-out; 
    }

    /* ë°°ê²½ ìŠ¤íƒ€ì¼ */
    .bg-home {
      background: linear-gradient(rgba(0,0,0,0.3), rgba(0,0,0,0.3)), url('https://images.unsplash.com/photo-1583847268964-b28dc8f51f92?q=80&w=1920&auto=format&fit=crop');
      background-size: cover; background-position: center;
    }
    .bg-spotlight {
      background: radial-gradient(circle at center, rgba(255,255,255,0.15) 0%, rgba(0,0,0,0.95) 40%, #000 70%);
      background-color: #000;
    }
    .bg-school {
      background: linear-gradient(rgba(0,0,0,0.3), rgba(0,0,0,0.3)), url('https://images.unsplash.com/photo-1517245386807-bb43f82c33c4?q=80&w=1920&auto=format&fit=crop');
      background-size: cover; background-position: center;
    }
    .bg-sky {
      background: linear-gradient(rgba(0,0,0,0.1), rgba(0,0,0,0.1)), url('https://images.unsplash.com/photo-1513002749550-c59d786b8e6c?q=80&w=1920&auto=format&fit=crop');
      background-size: cover; background-position: center;
    }

    .dialogue-box {
      width: 80%; max-width: 800px;
      background: rgba(0, 0, 0, 0.85);
      border: 2px solid #fff;
      border-radius: 10px;
      padding: 30px;
      color: #fff; font-size: 20px; line-height: 1.6;
      box-shadow: 0 0 20px rgba(0,0,0,0.8);
      position: relative;
      transition: opacity 0.5s;
    }
    .speaker-name { font-size: 24px; font-weight: bold; color: #ffeb3b; margin-bottom: 15px; }
    .dialogue-text { min-height: 60px; }
    .next-guide {
      position: absolute; bottom: 15px; right: 20px;
      font-size: 14px; color: #aaa; animation: blink 1s infinite;
    }
    @keyframes blink { 50% { opacity: 0; } }

    /* HUD & UI */
    #hud{
      position:absolute; top:20px; left:20px;
      color:#fff; font-size:18px;
      text-shadow:2px 2px 4px rgba(0,0,0,0.8);
      user-select:none; pointer-events: none; display:none;
    }
    #warningArea {
      position: absolute; top: 60px; left: 20px;
      display: flex; gap: 10px; pointer-events: none;
    }
    .yellow-card {
      width: 30px; height: 45px;
      background-color: #ffeb3b;
      border: 2px solid #fff; border-radius: 4px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
      animation: cardPop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    @keyframes cardPop { 0% { transform: scale(0) rotate(-180deg); opacity: 0; } 100% { transform: scale(1) rotate(0deg); opacity: 1; } }

    #damageOverlay {
      position: absolute; inset: 0;
      background: radial-gradient(circle, transparent 60%, rgba(255, 0, 0, 0.5));
      opacity: 0; transition: opacity 0.2s; pointer-events: none; z-index: 500;
    }

    /* [ìˆ˜ì •] ì»¨ë‹ í˜ì´í¼ í¬ê¸° í™•ëŒ€ */
    #cheatSheet {
      position: absolute; top: 20px; right: 20px;
      width: 400px; /* ê¸°ì¡´ 330px -> 400px (ì•½ 20% ì¦ê°€) */
      padding: 20px;
      background: rgba(255, 255, 255, 0.95);
      color: #000; border-radius: 5px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3); display: none;
      font-size: 16px; /* ê¸°ì¡´ 13px -> 16px (ì•½ 20% ì¦ê°€) */
      line-height: 1.6; transform: rotate(-2deg); border: 1px solid #ccc;
      white-space: nowrap; 
    }
    #cheatSheet h3 { text-align: center; margin-bottom: 10px; border-bottom: 2px solid #333; padding-bottom: 5px;}

    #answerSheet {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 650px; height: 500px;
      background: #fff; border: 1px solid #ccc;
      box-shadow: 0 20px 50px rgba(0,0,0,0.5); padding: 30px; display: none; 
      flex-direction: column; border-radius: 2px; z-index: 1200;
    }
    #answerSheet h2 { text-align: center; margin-bottom: 10px; font-family: "Gungsuh", serif; }
    .answer-warning {
      text-align: center; color: #d32f2f; font-weight: bold; font-size: 15px; margin-bottom: 10px;
      background: #ffebee; padding: 5px; border-radius: 4px;
    }

    #answerInput {
      flex: 1; width: 100%; padding: 15px; font-size: 16px; line-height: 1.8;
      border: 2px solid #ddd; background: #fdfdfd; resize: none; font-family: 'Malgun Gothic', sans-serif; outline: none;
    }
    #answerInput:focus { border-color: #4CAF50; }
    .sheet-guide { margin-top: 10px; font-size: 14px; color: #666; text-align: right; }

    #statusMsg {
      position: absolute; bottom: 100px; left: 50%;
      transform: translateX(-50%);
      color: #fff; font-size: 20px; font-weight: bold;
      text-shadow: 1px 1px 2px #000;
      opacity: 0; transition: opacity 0.3s; z-index: 1000;
    }
    #statusMsg.warning { color: #ffeb3b; font-size: 24px; text-shadow: 0 0 10px #f44336; }

    /* [ìˆ˜ì •] ì¡°ì‘ë²• UI í¬ê¸° í™•ëŒ€ ë° ìŠ¤íƒ€ì¼ */
    #controls{
      position:absolute; bottom:20px; left:20px;
      color:#fff; 
      font-size: 17px; /* ê¸°ì¡´ 14px -> 17px (ì•½ 20% ì¦ê°€) */
      text-shadow:2px 2px 4px rgba(0,0,0,0.8);
      background:rgba(0,0,0,0.5);
      padding:15px; /* íŒ¨ë”©ë„ ì•½ê°„ ì¦ê°€ */
      border-radius:5px;
      user-select:none; pointer-events: none; display:none;
      line-height: 1.6;
    }

    /* ì±„ì  í™”ë©´ */
    #gradingScreen {
      position: absolute; inset: 0;
      background: rgba(0,0,0,0.9);
      color: #fff;
      display: none; flex-direction: column; align-items: center; justify-content: center;
      z-index: 1400; padding: 40px;
    }
    .grading-title { font-size: 36px; margin-bottom: 30px; font-weight: bold; color: #ffeb3b; }
    .grading-table {
      display: flex; gap: 40px; width: 100%; max-width: 1200px;
      background: #222; padding: 20px; border-radius: 10px;
    }
    .grading-col { flex: 1; display: flex; flex-direction: column; gap: 10px; }
    .col-header { font-size: 24px; border-bottom: 2px solid #555; padding-bottom: 10px; margin-bottom: 10px; text-align: center;}
    .grade-item {
      background: #333; padding: 10px; border-radius: 5px; font-size: 16px; min-height: 45px; display: flex; align-items: center;
      word-break: break-all;
    }
    .grade-item.correct { border-left: 5px solid #4CAF50; color: #a5d6a7; }
    .grade-item.wrong { border-left: 5px solid #f44336; color: #ef9a9a; }
    .grading-btn {
      margin-top: 30px; padding: 15px 40px; font-size: 20px;
      background: #fff; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;
    }
    .grading-btn:hover { background: #eee; }

    /* THE END í™”ë©´ */
    #theEndScreen {
      position: absolute; inset: 0;
      display: none; flex-direction: column; align-items: center; justify-content: center;
      color: #fff; z-index: 3000; opacity: 0; transition: opacity 2s;
    }
    .the-end-text { font-size: 60px; font-weight: bold; margin-bottom: 20px; text-shadow: 0 0 20px rgba(255,255,255,0.5); }
    .the-end-sub { font-size: 28px; color: #ccc; margin-bottom: 40px; font-weight: normal; text-align: center; }
    .restart-btn {
      padding: 10px 20px; font-size: 18px; border: none; border-radius: 5px; cursor: pointer; background: #fff; color: #000; font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="gameContainer"></div>
  <div id="damageOverlay"></div>

  <div id="loadingScreen">
    <div class="loading-content">
      <div>ê²Œì„ ë¦¬ì†ŒìŠ¤ ë¡œë”© ì¤‘...</div>
      <div class="loading-bar"><div class="loading-progress"></div></div>
    </div>
  </div>

  <div id="dialogueScreen">
    <div class="dialogue-box" id="dialogueBox">
      <div class="speaker-name" id="speakerName"></div>
      <div class="dialogue-text" id="dialogueText"></div>
      <div class="next-guide">Enter í‚¤ë¥¼ ëˆŒëŸ¬ ê³„ì† â–¶</div>
    </div>
  </div>

  <div id="gradingScreen">
    <div class="grading-title">ğŸ“ ë‹µì•ˆì§€ ì±„ì  ì¤‘...</div>
    <div class="grading-table">
      <div class="grading-col">
        <div class="col-header" style="color:#4CAF50">ì •ë‹µ (ëª¨ë²” ë‹µì•ˆ)</div>
        <div id="correctList"></div>
      </div>
      <div class="grading-col">
        <div class="col-header" style="color:#ff9800">ë‚´ê°€ ì“´ ë‹µì•ˆ</div>
        <div id="myList"></div>
      </div>
    </div>
    <button class="grading-btn" onclick="finishGrading()">ê²°ê³¼ í™•ì¸</button>
  </div>

  <div id="hud">
    <div>â±ï¸ ë‚¨ì€ ì‹œê°„: <span id="timeLeft">80</span>ì´ˆ</div>
  </div>
  <div id="warningArea"></div>

  <div id="cheatSheet">
    <h3>[ì•ìë¦¬ ê³¼íƒ‘ ë‹µì•ˆì§€]</h3>
    <div id="cheatContent"></div>
  </div>

  <div id="answerSheet">
    <h2>ê¸°ë§ê³ ì‚¬ ë‹µì•ˆì§€</h2>
    <div class="answer-warning">â€» ì£¼ì˜: ë²ˆí˜¸ ìƒëµ, ë‹µë§Œ í•œ ì¤„ì— í•˜ë‚˜ì”©! (ëŒ€ì†Œë¬¸ì/ê¸°í˜¸ ì •í™•íˆ êµ¬ë¶„!)</div>
    <textarea id="answerInput" placeholder="[ì‘ì„± ì˜ˆì‹œ]&#13;&#10;orthographic projection&#13;&#10;MeshLambertMaterial"></textarea>
    <div class="sheet-guide">ì‘ì„± ì¤‘ì§€: <b>0</b> ë˜ëŠ” <b>ESC</b> í‚¤</div>
  </div>

  <div id="statusMsg"></div>

  <div id="controls">
    <div style="margin-bottom:5px;"><b>ğŸ® ì¡°ì‘ë²•</b></div>
    <div>- <b>ìŠ¤í˜ì´ìŠ¤ë°”</b> : ê³ ê°œë¥¼ ë“¤ì–´ ì»¨ë‹í•˜ê¸°</div>
    <div>- <b>9</b> : ë‹µì•ˆ ì‘ì„±</div>
    <div>- <b>0</b> : ë‹µì•ˆ ì‘ì„± ì¤‘ë‹¨</div>
    <div style="margin-top:5px; font-size: 0.9em; color:#ddd;">(ë§ˆìš°ìŠ¤: ì‹œì•¼ ì¡°ì ˆ)</div>
  </div>

  <div id="theEndScreen">
    <div class="the-end-text">THE END ...</div>
    <div class="the-end-sub" id="theEndSub"></div>
    <button class="restart-btn" onclick="location.reload()">ë‹¤ì‹œ í•˜ê¸°</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // --- ìŠ¤í† ë¦¬ ë°ì´í„° ---
    const INTRO_DIALOGUES = [
      { speaker: "ì—„ë§ˆ", text: "ë„ˆ ìš”ì¦˜ ê³µë¶€ì•ˆí•˜ê³  ë†€ëŸ¬ë‹¹ê¸´ë‹¤ë©°?", color: "#ff6b6b" },
      { speaker: "ë‚˜", text: "ì•„ë‹ˆì—ìš”! ì œê°€ ì–¼ë§ˆë‚˜ ê³µë¶€ë¥¼ ì—´ì‹¬íˆ í•˜ëŠ”ë°ìš” ....", color: "#4488ff" },
      { speaker: "ì—„ë§ˆ", text: "ë„ˆ ë‚´ì¼ ì‹œí—˜ ì•„ë‹ˆë‹ˆ? ì´ë²ˆì— ë§Œì  ëª» ë°›ì•„ì˜¤ë©´ ìš©ëˆ ëŠì„ ì¤„ ì•Œì•„ë¼!", color: "#ff6b6b" },
      { speaker: "ë‚˜", text: "( ... í°ì¼ë‚¬ë‹¤. ì‚¬ì‹¤ ê³µë¶€ë¥¼ í•˜ë‚˜ë„ ì•ˆ í–ˆëŠ”ë°. )", color: "#aaa" },
      { speaker: "ë‚˜", text: "ì•„ ë§ë‹¤! ë‚´ì¼ ê³¼íƒ‘ ë’¤ì— ì•‰ì•„ì•¼ì§€!!", color: "#4CAF50" },
      { speaker: "ë‚˜", text: "ì–´ë–»ê²Œë“  ê±” ë‹µì•ˆì„ ì»¨ë‹í•´ì„œ A+ë¥¼ ë°›ì•„ì•¼ í•´!", color: "#4CAF50" }
    ];

    const ENDING_SCENARIOS = {
      caught: [
        { speaker: "ì—„ë§ˆ", text: "ë„ˆ... ì„ ìƒë‹˜ê»˜ ì „í™”ì™”ë‹¤. ì‹œí—˜ì¹˜ë‹¤ ì»¨ë‹ì„ í–ˆë‹¤ê³ ?! ë‚´ê°€ ë„ ê·¸ë ‡ê²Œ ê°€ë¥´ì³¤ë‹ˆ!!", color: "#ff6b6b" },
        { speaker: "ë‚˜", text: "ì£„ì†¡í•´ìš”... ê³µë¶€ë¥¼ ì•ˆ í•´ì„œ ì ìˆ˜ë¼ë„ ì˜ ë°›ê³  ì‹¶ì–´ì„œ ê·¸ë§Œ...", color: "#aaa" },
        { speaker: "ë‚˜", text: "ì •ë§ ì˜ëª»í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œëŠ” ë¶€ì •í–‰ìœ„ ì•ˆ í• ê²Œìš”...", color: "#4CAF50" }
      ],
      fail_score: [
        { speaker: "ì—„ë§ˆ", text: "ì„±ì í‘œ ë‚˜ì™”ë‹¤. ì ìˆ˜ê°€ ì´ê²Œ ë­ë‹ˆ?", color: "#ff6b6b" },
        { speaker: "ë‚˜", text: "ê·¸ê²Œ... ë‹µì„ ì¢€ ì˜ëª» ì ì–´ì„œ...", color: "#4488ff" },
        { speaker: "ì—„ë§ˆ", text: "ë„ˆ ë§Œì  ë°›ëŠ”ë‹¤ê³  í–ˆì–ì•„! ë‹¹ë¶„ê°„ ìš©ëˆì€ ì—†ë‹¤!", color: "#ff6b6b" }
      ],
      success: [
        { speaker: "ì—„ë§ˆ", text: "ì„¸ìƒì—! ìš°ë¦¬ ì•„ë“¤ì´ ì‹œí—˜ ë§Œì  ë°›ì•˜ë„¤!", color: "#ff6b6b" },
        { speaker: "ë‚˜", text: "ì™€! ì§„ì§œìš”? (íœ´... ì™„ë²½í•˜ê²Œ ì„±ê³µí–ˆë‹¤!)", color: "#4488ff" },
        { speaker: "ì—„ë§ˆ", text: "ì •ë§ ìë‘ìŠ¤ëŸ½ë‹¤! ì˜¤ëŠ˜ ì €ë…ì€ ë„¤ê°€ ì¢‹ì•„í•˜ëŠ” ê±¸ë¡œ ë¨¹ì!", color: "#ff6b6b" },
        { speaker: "ë‚˜", text: "ì•—ì‹¸! ì—„ë§ˆ ì‚¬ë‘í•´ìš”!", color: "#4488ff" }
      ]
    };

    // ë¬¸ì œ í’€
    const PROBLEM_POOL = [
      "orthographic projection", "viewport transformation", "MeshLambertMaterial",
      "z value interpolation", "world coordinate system", "quternion multiplication",
      "Phong reflection model", "ambient reflection and diffuse reflection",
      "element array buffer", "keyframe interplolation", "FFmpeg video",
      "MeshPhongMaterial", "gl.Depth_BUFFER_BIT", "indirect illumination",
      "perspective transformation", "UVN coordinate system", "gl.ELEMENT_ARRAY_BUFFER"
    ];

    let currentCorrectAnswers = [];

    const game = {
      scene: null, camera: null, renderer: null,
      player: {
        position: new THREE.Vector3(0, 1.5, 0),
        seat: { row: 2, col: 3 },
        eyeYBase: 1.5, eyeYStand: 2.05, eyeYSmooth: 1.5, standSpeed: 8.5
      },
      npcs: [],
      isCheating: false, isWriting: false,
      timeLeft: 80, 
      state: 'loading', 
      
      currentDialogueSet: [],
      dialogueIndex: 0, charIndex: 0, typingInterval: null, onDialogueEnd: null, 
      warnings: 0, maxWarnings: 3,
      isInvincible: false, invincibleTime: 3.0, currentInvincibleTime: 0,
      clock: new THREE.Clock(),
      mouse: { x: Math.PI, y: 0, sensitivity: 0.002 },
      userAnswers: [] 
    };

    const BASE_YAW = Math.PI;
    const ROOM_W = 25; const ROOM_D = 30; const WALL_H = 6;
    const FRONT_Z = ROOM_D / 2; const BACK_Z = -ROOM_D / 2;
    const LEFT_X = -ROOM_W / 2; const RIGHT_X = ROOM_W / 2;
    const TEACHER_Z = FRONT_Z - 3.0;

    const DESK_ROWS = 4; const DESK_COLS = 5;
    const GAP_X = 4.2; const GAP_Z = 4.8; 
    const START_Z = 8.0; const START_X = -( (DESK_COLS - 1) * GAP_X ) / 2;

    function init() {
      setupRandomAnswers();
      const cheatContent = document.getElementById('cheatContent');
      currentCorrectAnswers.forEach((ans, idx) => {
        const p = document.createElement('div');
        p.style.marginBottom = "8px";
        p.textContent = `${idx + 1}. ${ans}`;
        cheatContent.appendChild(p);
      });

      const container = document.getElementById('gameContainer');
      game.scene = new THREE.Scene();
      game.scene.background = new THREE.Color(0xf0f0f0);
      game.scene.fog = new THREE.Fog(0xf0f0f0, 8, 28);

      game.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
      game.camera.rotation.order = 'YXZ';

      game.renderer = new THREE.WebGLRenderer({ antialias: true });
      game.renderer.setSize(window.innerWidth, window.innerHeight);
      game.renderer.shadowMap.enabled = true;
      container.appendChild(game.renderer.domElement);

      game.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(5, 10, 5); dir.castShadow = true;
      game.scene.add(dir);

      createEnvironment();
      createClassroom();
      createNPCs();
      setupInputs();
      
      setTimeout(() => {
        document.getElementById('loadingScreen').classList.add('hidden');
        startDialogue(INTRO_DIALOGUES, () => {
          startGameplay();
        }, 'bg-home');
      }, 500);

      animate();
    }

    function setupRandomAnswers() {
      const shuffled = [...PROBLEM_POOL].sort(() => 0.5 - Math.random());
      currentCorrectAnswers = shuffled.slice(0, 5);
    }

    function startDialogue(dialogueSet, onEndCallback, bgClass) {
      game.state = 'dialogue';
      game.currentDialogueSet = dialogueSet;
      game.dialogueIndex = 0;
      game.onDialogueEnd = onEndCallback;
      
      const screen = document.getElementById('dialogueScreen');
      screen.className = ''; if (bgClass) screen.classList.add(bgClass);
      screen.style.display = 'flex'; screen.style.opacity = 1;
      document.getElementById('dialogueBox').style.opacity = 1;
      document.getElementById('hud').style.display = 'none';
      document.getElementById('controls').style.display = 'none';
      document.getElementById('cheatSheet').style.display = 'none';
      document.exitPointerLock();
      showDialogue(0);
    }

    function showDialogue(index) {
      if (index >= game.currentDialogueSet.length) {
        if (game.onDialogueEnd) game.onDialogueEnd();
        return;
      }
      game.dialogueIndex = index;
      const data = game.currentDialogueSet[index];
      const nameEl = document.getElementById('speakerName');
      const textEl = document.getElementById('dialogueText');
      nameEl.textContent = data.speaker; nameEl.style.color = data.color; textEl.textContent = "";
      game.charIndex = 0;
      if (game.typingInterval) clearInterval(game.typingInterval);
      game.typingInterval = setInterval(() => {
        textEl.textContent += data.text.charAt(game.charIndex);
        game.charIndex++;
        if (game.charIndex >= data.text.length) {
          clearInterval(game.typingInterval);
          game.typingInterval = null;
        }
      }, 30); 
    }

    function nextDialogue() {
      if (game.typingInterval) {
        clearInterval(game.typingInterval);
        game.typingInterval = null;
        document.getElementById('dialogueText').textContent = game.currentDialogueSet[game.dialogueIndex].text;
      } else {
        showDialogue(game.dialogueIndex + 1);
      }
    }

    function startGameplay() {
      game.state = 'playing';
      document.getElementById('dialogueScreen').style.display = 'none'; 
      document.getElementById('hud').style.display = 'block';
      document.getElementById('controls').style.display = 'block';
      const mySeat = game.player.position; game.camera.position.copy(mySeat);
      game.mouse.x = Math.PI; game.mouse.y = 0;
      game.renderer.domElement.requestPointerLock();
    }

    function showGradingScreen() {
      game.state = 'grading';
      document.exitPointerLock();
      document.getElementById('answerSheet').style.display = 'none';
      document.getElementById('hud').style.display = 'none';
      document.getElementById('controls').style.display = 'none';
      document.getElementById('gradingScreen').style.display = 'flex';

      const rawText = document.getElementById('answerInput').value;
      const lines = rawText.split('\n').map(l => l.trim()).filter(l => l.length > 0);
      game.userAnswers = lines;

      const correctListDiv = document.getElementById('correctList');
      const myListDiv = document.getElementById('myList');
      correctListDiv.innerHTML = ''; myListDiv.innerHTML = '';

      for(let i=0; i<currentCorrectAnswers.length; i++) {
        const correctItem = document.createElement('div');
        correctItem.className = 'grade-item correct';
        correctItem.textContent = `${i+1}. ${currentCorrectAnswers[i]}`;
        correctListDiv.appendChild(correctItem);

        const myAns = game.userAnswers[i] || "(ë¯¸ì‘ì„±)";
        const isMatch = (myAns === currentCorrectAnswers[i]);
        const myItem = document.createElement('div');
        myItem.className = isMatch ? 'grade-item correct' : 'grade-item wrong';
        myItem.textContent = `${i+1}. ${myAns}`;
        if (!isMatch) myItem.textContent += " (X)";
        myListDiv.appendChild(myItem);
      }
    }

    function finishGrading() {
      document.getElementById('gradingScreen').style.display = 'none';
      let correctCount = 0;
      for(let i=0; i<currentCorrectAnswers.length; i++) {
        if(game.userAnswers[i] === currentCorrectAnswers[i]) correctCount++;
      }
      const isPerfect = (correctCount === currentCorrectAnswers.length);
      if(isPerfect) {
        startDialogue(ENDING_SCENARIOS.success, () => { triggerHappyEndOverlay(); }, 'bg-home');
      } else {
        startDialogue(ENDING_SCENARIOS.fail_score, () => { triggerHappyEndOverlay(); }, 'bg-home');
      }
    }

    function triggerHappyEndOverlay() {
      document.getElementById('dialogueBox').style.opacity = 0;
      const theEndScreen = document.getElementById('theEndScreen');
      document.getElementById('theEndSub').textContent = ""; 
      theEndScreen.style.display = 'flex';
      theEndScreen.style.background = 'transparent'; 
      setTimeout(() => { theEndScreen.style.opacity = 1; }, 100);
      game.state = 'finished';
    }

    function triggerCaughtEnding() {
      const dialogueScreen = document.getElementById('dialogueScreen');
      dialogueScreen.style.opacity = 0; 
      setTimeout(() => {
        dialogueScreen.style.display = 'none';
        const theEndScreen = document.getElementById('theEndScreen');
        document.getElementById('theEndSub').textContent = "ì—¬ëŸ¬ë¶„ ë¶€ì •í–‰ìœ„ë¥¼ í•˜ì§€ ë§™ì‹œë‹¤";
        theEndScreen.style.display = 'flex';
        theEndScreen.style.background = '#000'; 
        setTimeout(() => { theEndScreen.style.opacity = 1; }, 100);
        game.state = 'finished'; 
      }, 500);
    }

    function createEnvironment() {
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_W, ROOM_D), new THREE.MeshStandardMaterial({ color: 0xd4a574, roughness: 0.85 }));
      floor.rotation.x = -Math.PI / 2; floor.receiveShadow = true;
      game.scene.add(floor);

      const wallMat = new THREE.MeshStandardMaterial({ color: 0xe8e8e8 });
      const makeWall = (w, h, d, x, y, z) => {
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), wallMat);
        mesh.position.set(x, y, z); game.scene.add(mesh);
      };
      makeWall(ROOM_W, WALL_H, 0.2, 0, WALL_H/2, FRONT_Z);
      makeWall(ROOM_W, WALL_H, 0.2, 0, WALL_H/2, BACK_Z);
      makeWall(0.2, WALL_H, ROOM_D, LEFT_X, WALL_H/2, 0);
      makeWall(0.2, WALL_H, ROOM_D, RIGHT_X, WALL_H/2, 0);
      
      const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_W, ROOM_D), new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide }));
      ceiling.rotation.x = Math.PI / 2; ceiling.position.y = WALL_H;
      game.scene.add(ceiling);

      const bb = new THREE.Mesh(new THREE.BoxGeometry(8, 3, 0.1), new THREE.MeshStandardMaterial({ color: 0x1a4d2e }));
      bb.position.set(0, 3, FRONT_Z - 0.2); game.scene.add(bb);
      const pd = new THREE.Mesh(new THREE.BoxGeometry(8.5, 0.35, 2.3), new THREE.MeshStandardMaterial({ color: 0x8b6f47 }));
      pd.position.set(0, 0.18, FRONT_Z - 2.0); game.scene.add(pd);

      // ì°½ë¬¸ (ì™¼ìª½)
      const winGeo = new THREE.BoxGeometry(0.2, 2.5, 3.5);
      const winMat = new THREE.MeshStandardMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.6 });
      const frameMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const zPositions = [5, 0, -5];
      zPositions.forEach(z => {
        const glass = new THREE.Mesh(winGeo, winMat); glass.position.set(LEFT_X + 0.1, 3.5, z); game.scene.add(glass);
        const frameT = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.1, 3.7), frameMat); frameT.position.set(LEFT_X + 0.1, 3.5 + 1.25, z); game.scene.add(frameT);
        const frameB = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.1, 3.7), frameMat); frameB.position.set(LEFT_X + 0.1, 3.5 - 1.25, z); game.scene.add(frameB);
        const frameL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 2.5, 0.1), frameMat); frameL.position.set(LEFT_X + 0.1, 3.5, z - 1.75); game.scene.add(frameL);
        const frameR = new THREE.Mesh(new THREE.BoxGeometry(0.3, 2.5, 0.1), frameMat); frameR.position.set(LEFT_X + 0.1, 3.5, z + 1.75); game.scene.add(frameR);
      });

      // ë¬¸ (ì˜¤ë¥¸ìª½)
      const doorGeo = new THREE.BoxGeometry(0.2, 4.5, 2.5); const doorMat = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
      const d1 = new THREE.Mesh(doorGeo, doorMat); d1.position.set(RIGHT_X - 0.1, 2.25, FRONT_Z - 5); game.scene.add(d1);
      const h1 = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshStandardMaterial({ color: 0xaaaaaa })); h1.position.set(RIGHT_X - 0.25, 2.25, FRONT_Z - 4.2); game.scene.add(h1);
      const d2 = new THREE.Mesh(doorGeo, doorMat); d2.position.set(RIGHT_X - 0.1, 2.25, BACK_Z + 5); game.scene.add(d2);
      const h2 = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshStandardMaterial({ color: 0xaaaaaa })); h2.position.set(RIGHT_X - 0.25, 2.25, BACK_Z + 5.8); game.scene.add(h2);

      // ì²œì¥ LED
      const ledGeo = new THREE.BoxGeometry(2.5, 0.05, 0.5);
      const ledMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x555555 });
      for (let z = FRONT_Z - 4; z > BACK_Z + 4; z -= 7) {
        for (let x = LEFT_X + 5; x < RIGHT_X - 5; x += 7) {
            const led = new THREE.Mesh(ledGeo, ledMat); led.position.set(x, WALL_H - 0.025, z); game.scene.add(led);
        }
      }

      // [ìˆ˜ì •] ì‹œê³„ ìœ„ì¹˜ ì´ë™ (x=6.5)
      const clockGroup = new THREE.Group();
      const frame = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 0.1, 32), new THREE.MeshStandardMaterial({ color: 0x333333 }));
      frame.rotation.x = Math.PI / 2; clockGroup.add(frame);
      const face = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.7, 0.11, 32), new THREE.MeshStandardMaterial({ color: 0xffffff }));
      face.rotation.x = Math.PI / 2; clockGroup.add(face);
      const handMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
      const hHand = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.05, 0.12), handMat); hHand.position.set(0.2, 0, 0.06); clockGroup.add(hHand);
      const mHand = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.04, 0.12), handMat); mHand.position.set(0, 0.3, 0.06); mHand.rotation.z = Math.PI/2; clockGroup.add(mHand);
      clockGroup.position.set(6.5, 3.5, FRONT_Z - 0.15); // ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™
      game.scene.add(clockGroup);
    }

    function createClassroom() {
      const desks = [];
      const scale = 1.21; 

      for (let r = 0; r < DESK_ROWS; r++) {
        for (let c = 0; c < DESK_COLS; c++) {
          const x = START_X + c * GAP_X;
          const z = START_Z - r * GAP_Z;
          
          const desk = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.12, 1.05), new THREE.MeshStandardMaterial({ color: 0xa67c52 }));
          desk.position.set(x, 0.72, z); desk.scale.set(scale, scale, scale); desk.castShadow = true; game.scene.add(desk);
          const paper = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.01, 0.7), new THREE.MeshStandardMaterial({ color: 0xffffff }));
          paper.position.set(x, 0.79, z); paper.scale.set(scale, scale, scale); paper.receiveShadow = true; game.scene.add(paper);
          const chair = new THREE.Mesh(new THREE.BoxGeometry(0.85, 0.12, 0.85), new THREE.MeshStandardMaterial({ color: 0x4a4a4a }));
          chair.position.set(x, 0.42, z - 0.75); chair.scale.set(scale, scale, scale); game.scene.add(chair);
          desks.push({ pos: new THREE.Vector3(x, 0, z), row: r+1, col: c+1 });
        }
      }
      const mySeat = desks.find(d => d.row === 2 && d.col === 3).pos;
      game.player.position.set(mySeat.x, game.player.eyeYBase, mySeat.z - 0.4);
      game.player.eyeYSmooth = game.player.eyeYBase;

      const playerModel = createPerson(0xff6b6b, 'student');
      playerModel.position.set(mySeat.x, 0, mySeat.z - 0.75); 
      playerModel.rotation.y = 0;
      playerModel.traverse(child => { if (child.isMesh) { child.material.transparent = true; child.material.opacity = 0; } });
      game.scene.add(playerModel);

      const palette = [0x4488ff, 0xff6b6b, 0x51cf66, 0xffd43b, 0x845ef7];
      for (const d of desks) {
        if (d.row === 2 && d.col === 3) continue;
        const s = createPerson(palette[Math.floor(Math.random() * palette.length)], 'student');
        s.position.set(d.pos.x, 0, d.pos.z - 0.75);
        s.rotation.y = 0;
        game.scene.add(s);
      }
    }

    function createPerson(shirtColor, type) {
      const group = new THREE.Group();
      group.scale.set(1.21, 1.21, 1.21); 

      const skinColors = [0xffdbac, 0xf1c27d, 0xe0ac69, 0x8d5524];
      const hairColors = [0x090806, 0x2c1608, 0x3b3024, 0x4e433f, 0xe6cea8];
      const skinColor = skinColors[Math.floor(Math.random() * skinColors.length)];
      const hairColor = hairColors[Math.floor(Math.random() * hairColors.length)];
      const shirtMat = new THREE.MeshStandardMaterial({ color: shirtColor });
      const pantsMat = new THREE.MeshStandardMaterial({ color: 0x333333 }); 
      const skinMat = new THREE.MeshStandardMaterial({ color: skinColor });
      const hairMat = new THREE.MeshStandardMaterial({ color: hairColor });
      const isSitting = (type === 'student');

      if (isSitting) {
        const hips = new THREE.Mesh(new THREE.BoxGeometry(0.44, 0.15, 0.35), pantsMat); hips.position.y = 0.5; group.add(hips);
        const lThigh = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.16, 0.45), pantsMat); lThigh.position.set(-0.11, 0.5, 0.25); group.add(lThigh);
        const lCalf = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.45, 0.16), pantsMat); lCalf.position.set(-0.11, 0.25, 0.4); group.add(lCalf);
        const rThigh = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.16, 0.45), pantsMat); rThigh.position.set(0.11, 0.5, 0.25); group.add(rThigh);
        const rCalf = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.45, 0.16), pantsMat); rCalf.position.set(0.11, 0.25, 0.4); group.add(rCalf);
        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.44, 0.55, 0.22), shirtMat); torso.position.y = 0.85; group.add(torso);
        const lArm = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.4, 0.13), shirtMat); lArm.position.set(-0.28, 1.0, 0.1); lArm.rotation.x = -0.5; lArm.rotation.z = 0.2; group.add(lArm);
        const lForearm = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.35, 0.13), skinMat); lForearm.position.set(-0.32, 0.85, 0.35); lForearm.rotation.x = -1.6; lForearm.rotation.y = 0.3; group.add(lForearm);
        const rArm = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.4, 0.13), shirtMat); rArm.position.set(0.28, 1.0, 0.1); rArm.rotation.x = -0.5; rArm.rotation.z = -0.2; group.add(rArm);
        const rForearm = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.35, 0.13), skinMat); rForearm.position.set(0.32, 0.85, 0.35); rForearm.rotation.x = -1.6; rForearm.rotation.y = -0.3; group.add(rForearm);
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.26, 0.28, 0.28), skinMat); head.position.y = 1.28; group.add(head);
        const hair = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.12, 0.3), hairMat); hair.position.y = 1.38; group.add(hair);
        const hairBack = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.28, 0.1), hairMat); hairBack.position.set(0, 1.28, -0.1); group.add(hairBack);
      } else {
        const lLeg = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.85, 0.16), pantsMat); lLeg.position.set(-0.12, 0.425, 0); group.add(lLeg);
        const rLeg = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.85, 0.16), pantsMat); rLeg.position.set(0.12, 0.425, 0); group.add(rLeg);
        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.46, 0.65, 0.25), shirtMat); torso.position.y = 1.18; group.add(torso);
        const lArm = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.7, 0.14), shirtMat); lArm.position.set(-0.32, 1.15, 0); group.add(lArm);
        const rArm = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.7, 0.14), shirtMat); rArm.position.set(0.32, 1.15, 0); group.add(rArm);
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.26, 0.28, 0.28), skinMat); head.position.y = 1.65; group.add(head);
        const hair = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.1, 0.3), hairMat); hair.position.y = 1.76; group.add(hair);
      }
      return group;
    }

    function createNPCs() {
      game.npcs.push(createNPC(0, TEACHER_Z, 0x2c3e50, 'teacher'));
      game.npcs.push(createNPC(LEFT_X + 2.5, 1.5, 0x34495e, 'invigilator'));
      game.npcs.push(createNPC(RIGHT_X - 2.5, 1.5, 0x34495e, 'invigilator'));
    }

    function createNPC(x, z, color, role) {
      const group = new THREE.Group();
      const person = createPerson(color, 'invigilator'); 
      if(role === 'teacher') person.scale.set(1.1, 1.1, 1.1);
      group.add(person);

      const isTeacher = role === 'teacher';
      const visionDistance = isTeacher ? 13 : 12;
      const visionRadius = isTeacher ? 5.0 : 4.8;
      const eyeHeight = isTeacher ? 2.0 : 1.75;
      const visionAngle = isTeacher ? Math.PI / 5.5 : Math.PI / 4;

      const coneGeom = new THREE.ConeGeometry(visionRadius, visionDistance, 32, 1, true);
      coneGeom.translate(0, -visionDistance / 2, 0);
      const coneMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
      const vision = new THREE.Mesh(coneGeom, coneMat);
      vision.rotation.x = -Math.PI / 2; vision.position.y = eyeHeight;
      group.add(vision);

      group.position.set(x, 0, z); group.rotation.y = BASE_YAW; 
      game.scene.add(group);
      return { role, group, eyeHeight, visionDistance, visionAngle, podiumLeftX: -3.5, podiumRightX: 3.5, moveSpeed: 1.6 + Math.random(), moveDir: Math.random() < 0.5 ? 1 : -1, scanTime: Math.random() * 10, angle: Math.random() * 10, rotationSpeed: 0.5 };
    }

    function setupInputs() {
      document.addEventListener('keydown', (e) => {
        if (game.state === 'dialogue' && e.code === 'Enter') { nextDialogue(); return; }
        if (e.code === 'Space' && game.state === 'playing' && !game.isWriting) { game.isCheating = true; document.getElementById('cheatSheet').style.display = 'block'; }
      });
      document.addEventListener('keyup', (e) => {
        if (e.code === 'Space') { game.isCheating = false; document.getElementById('cheatSheet').style.display = 'none'; }
      });
      window.addEventListener('keydown', (e) => {
        if (game.state !== 'playing') return;
        if (e.code === 'Digit9') { 
          e.preventDefault(); 
          if (!game.isWriting && !game.isCheating) toggleWritingMode(true); 
        }
        if (e.code === 'Digit0' || e.code === 'Escape') { 
          if (game.isWriting) toggleWritingMode(false); 
        }
      });
      document.addEventListener('mousemove', (e) => {
        if (game.state !== 'playing' || game.isWriting) return;
        if (document.pointerLockElement !== game.renderer.domElement) return;
        game.mouse.x += e.movementX * game.mouse.sensitivity;
        game.mouse.y += e.movementY * game.mouse.sensitivity;
        game.mouse.y = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, game.mouse.y));
      });
      game.renderer.domElement.addEventListener('click', () => {
        if (game.state === 'dialogue') { nextDialogue(); return; }
        if (game.state === 'playing' && !game.isWriting) game.renderer.domElement.requestPointerLock();
      });
      document.getElementById('answerInput').addEventListener('keydown', (e) => {
        e.stopPropagation();
        if (e.code === 'Digit0' || e.code === 'Escape') { e.preventDefault(); toggleWritingMode(false); return; }
      });
    }

    function toggleWritingMode(on) {
      game.isWriting = on;
      const sheet = document.getElementById('answerSheet');
      const input = document.getElementById('answerInput');
      const msg = document.getElementById('statusMsg');

      if (on) {
        document.exitPointerLock(); sheet.style.display = 'flex'; input.focus();
        game.mouse.x = Math.PI; game.mouse.y = Math.PI / 2.5; 
        msg.textContent = "âœï¸ ë‹µì•ˆ ì‘ì„± ì¤‘... (ì„ ìƒë‹˜ê»˜ ì•ˆì „)"; msg.style.opacity = 1;
      } else {
        sheet.style.display = 'none'; game.renderer.domElement.requestPointerLock(); msg.style.opacity = 0;
      }
    }

    function updateTeacher(npc, delta) {
      npc.group.position.x += npc.moveDir * npc.moveSpeed * delta;
      if (npc.group.position.x < npc.podiumLeftX) { npc.group.position.x = npc.podiumLeftX; npc.moveDir = 1; }
      if (npc.group.position.x > npc.podiumRightX) { npc.group.position.x = npc.podiumRightX; npc.moveDir = -1; }
      npc.scanTime += 1.6 * delta;
      npc.group.rotation.y = BASE_YAW + Math.sin(npc.scanTime) * 0.42;
    }

    function updateInvigilator(npc, delta) {
      npc.angle += npc.rotationSpeed * delta;
      const swing = Math.abs(Math.sin(npc.angle) * 0.7); 
      if (npc.group.position.x < 0) npc.group.rotation.y = BASE_YAW - swing;
      else npc.group.rotation.y = BASE_YAW + swing;
    }

    function handleWarning() {
      if (game.isInvincible) return;
      game.warnings++;
      
      const warningArea = document.getElementById('warningArea');
      const card = document.createElement('div'); card.className = 'yellow-card'; warningArea.appendChild(card);
      const overlay = document.getElementById('damageOverlay'); overlay.style.opacity = 1; setTimeout(() => overlay.style.opacity = 0, 300);

      if (game.warnings >= game.maxWarnings) {
        game.isCheating = false; document.getElementById('cheatSheet').style.display = 'none';
        startDialogue(ENDING_SCENARIOS.caught, () => {
           triggerCaughtEnding();
        }, 'bg-spotlight');
        return;
      }

      game.isInvincible = true; game.currentInvincibleTime = game.invincibleTime;
      const msg = document.getElementById('statusMsg'); msg.textContent = `âš ï¸ ê²½ê³ ! (${game.warnings}/3) - 3ì´ˆê°„ ì£¼ì˜í•˜ì„¸ìš”!`;
      msg.className = 'warning'; msg.style.opacity = 1;
      game.isCheating = false; document.getElementById('cheatSheet').style.display = 'none';
    }

    function animate() {
      requestAnimationFrame(animate);

      if (game.state === 'dialogue' && document.getElementById('dialogueScreen').classList.contains('bg-school')) {
        const time = Date.now() * 0.0002;
        game.camera.position.x = Math.sin(time) * 15; game.camera.position.z = Math.cos(time) * 15 + 5;
        game.camera.lookAt(0, 0, 0); game.renderer.render(game.scene, game.camera); return;
      }
      if (game.state !== 'playing') { 
        if (game.state !== 'finished') game.renderer.render(game.scene, game.camera); 
        return; 
      }

      const delta = game.clock.getDelta();

      if (game.isInvincible) {
        game.currentInvincibleTime -= delta;
        if (game.currentInvincibleTime <= 0) {
          game.isInvincible = false;
          const msg = document.getElementById('statusMsg'); if (msg.className === 'warning') msg.style.opacity = 0;
        }
      }

      game.camera.rotation.y = -game.mouse.x; game.camera.rotation.x = -game.mouse.y;
      const targetEyeY = (game.isCheating && !game.isWriting) ? game.player.eyeYStand : game.player.eyeYBase;
      const t = 1 - Math.exp(-game.player.standSpeed * delta);
      game.player.eyeYSmooth += (targetEyeY - game.player.eyeYSmooth) * t;
      game.camera.position.y = game.player.eyeYSmooth;

      game.timeLeft -= delta;
      document.getElementById('timeLeft').textContent = Math.ceil(Math.max(0, game.timeLeft));
      
      if (game.timeLeft <= 0) {
        showGradingScreen();
        return;
      }

      let caught = false;
      for (const npc of game.npcs) {
        if (npc.role === 'teacher') updateTeacher(npc, delta); else updateInvigilator(npc, delta);
        if (game.isCheating && !game.isWriting) {
          const npcPos = new THREE.Vector3(); npc.group.getWorldPosition(npcPos); npcPos.y = npc.eyeHeight;
          const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(npc.group.quaternion);
          const toPlayer = new THREE.Vector3().subVectors(game.player.position, npcPos).normalize();
          const distance = game.player.position.distanceTo(npcPos);
          const angle = Math.acos(THREE.MathUtils.clamp(forward.dot(toPlayer), -1, 1));
          if (angle < npc.visionAngle / 2 && distance < npc.visionDistance) caught = true;
        }
      }
      if (caught) handleWarning();

      game.renderer.render(game.scene, game.camera);
    }

    init();
  </script>
</body>
</html>